theory wpa2_four_way_handshake begin

// Function signature and definition of the equational theory E

builtins: multiset
functions: GTK/1, KDF/1, MIC/2, N/1, S/1, fst/1, pair/2, sdec/2, senc/2,
           snd/1, sndec/2, snenc/3
equations:
    fst(<x.1, x.2>) = x.1,
    sdec(senc(x.1, x.2), x.2) = x.1,
    snd(<x.1, x.2>) = x.2,
    sndec(snenc(message, key, nonce), key) = message



/*
looping facts with injective instances:
  AuthInstalledGTK/2, AuthState/3, ReceiverGTK/6, SuppState/3
*/

restriction Neq:
  "∀ x y #i. (Neq( x, y ) @ #i) ⇒ (¬(x = y))"
  // safety formula

restriction Equality:
  "∀ x y #i. (Eq( x, y ) @ #i) ⇒ (x = y)"
  // safety formula

restriction MessagesAreSentInEnqueueOrder:
  "∀ senderThreadID messageID1 messageID2 #i1 #j1 #i2 #j2.
    (((((EnqueueMessage( senderThreadID, messageID1 ) @ #i1) ∧
        (EnqueueMessage( senderThreadID, messageID2 ) @ #j1)) ∧
       (SendMessage( senderThreadID, messageID1 ) @ #i2)) ∧
      (SendMessage( senderThreadID, messageID2 ) @ #j2)) ∧
     (#i1 < #j1)) ⇒
    (#i2 < #j2)"
  // safety formula

restriction ReplayCounterM1:
  "∀ suppThreadID suppID PMK authThreadID PTK GTK ANonce SNonce ctr_m1 #i.
    (SupplicantReceivesM1( suppThreadID, suppID, PMK, authThreadID, PTK, GTK,
                           ANonce, SNonce, ctr_m1
     ) @ #i) ⇒
    (¬(∃ #j.
        (#j < #i) ∧ (SupplicantSeesCounter( suppThreadID, PMK, ctr_m1 ) @ #j)))"
  // safety formula

restriction ReplayCounterM1Again:
  "∀ suppThreadID suppID PMK authThreadID PTK GTK ANonce SNonce ctr_m1 #i.
    (SupplicantReceivesM1Again( suppThreadID, suppID, PMK, authThreadID, PTK,
                                GTK, ANonce, SNonce, ctr_m1
     ) @ #i) ⇒
    (¬(∃ #j.
        (#j < #i) ∧ (SupplicantSeesCounter( suppThreadID, PMK, ctr_m1 ) @ #j)))"
  // safety formula

restriction ReplayCounterM3:
  "∀ suppThreadID suppID PMK authThreadID PTK ANonce SNonce GTK ctr_m3 #i.
    (SupplicantReceivesM3( suppThreadID, suppID, PMK, authThreadID, PTK, GTK,
                           ANonce, SNonce, ctr_m3
     ) @ #i) ⇒
    (¬(∃ #j.
        (#j < #i) ∧ (SupplicantSeesCounter( suppThreadID, PMK, ctr_m3 ) @ #j)))"
  // safety formula

restriction ReplayCounterM3Again:
  "∀ suppThreadID suppID PMK authThreadID PTK GTK ANonce SNonce ctr_m3 #i.
    (SupplicantReceivesM3Again( suppThreadID, suppID, PMK, authThreadID, PTK,
                                GTK, ANonce, SNonce, ctr_m3
     ) @ #i) ⇒
    (¬(∃ #j.
        (#j < #i) ∧ (SupplicantSeesCounter( suppThreadID, PMK, ctr_m3 ) @ #j)))"
  // safety formula

restriction ReplayCounterGroupKeyRekey:
  "∀ suppThreadID suppID PMK authThreadID PTK oldGTK newGTK ANonce SNonce
     ctr #i.
    (SupplicantGroupKeyRekey( suppThreadID, suppID, PMK, authThreadID, PTK,
                              oldGTK, newGTK, ANonce, SNonce, ctr
     ) @ #i) ⇒
    (¬(∃ #j.
        (#j < #i) ∧ (SupplicantSeesCounter( suppThreadID, PMK, ctr ) @ #j)))"
  // safety formula

restriction ReplayCounterPairwiseMessages:
  "∀ ptkID receiverThreadID senderID PTK n1 n2 frameType #i #j.
    (((SeesNonceForPTK( ptkID, receiverThreadID, PTK,
                        <N(n1), senderID, frameType>
       ) @ #i) ∧
      (SeesNonceForPTK( ptkID, receiverThreadID, PTK,
                        <N(n2), senderID, frameType>
       ) @ #j)) ∧
     (#i < #j)) ⇒
    (∃ z. (n1+z) = n2)"

restriction ReplayCounterGroupPayload:
  "∀ keyID receiverThreadID senderID groupKey n1 n2 #i #j.
    (((SeesNonceForGTK( keyID, receiverThreadID, groupKey, <N(n1), senderID>
       ) @ #i) ∧
      (SeesNonceForGTK( keyID, receiverThreadID, groupKey, <N(n2), senderID>
       ) @ #j)) ∧
     (#i < #j)) ⇒
    (∃ z. (n1+z) = n2)"

restriction MemoryCanBeFreedOnlyOnce:
  "∀ pointer #i #j.
    ((Free( pointer ) @ #i) ∧ (Free( pointer ) @ #j)) ⇒ (#i = #j)"
  // safety formula

restriction FreedMemoryCannotBeAccessed:
  "∀ pointer #i #j.
    ((Read( pointer ) @ #i) ∧ (Free( pointer ) @ #j)) ⇒ (#i < #j)"
  // safety formula

restriction FreedUniqueMemoryCannotBeAccessed:
  "∀ pointer owner #i #j.
    ((ReadUnique( pointer, owner ) @ #i) ∧ (Free( pointer ) @ #j)) ⇒
    (#i < #j)"
  // safety formula

restriction UniqueMemoryMustBeUnique:
  "∀ pointer1 owner #i #j.
    ((AllocateUnique( pointer1, owner ) @ #i) ∧
     (ReadUnique( pointer1, owner ) @ #j)) ⇒
    ((#i < #j) ∧
     (¬(∃ pointer2 #k.
         ((#i < #k) ∧ (#k < #j)) ∧ (AllocateUnique( pointer2, owner ) @ #k))))"
  // safety formula

rule (modulo E) Supp_Create[color=#b5d1ff]:
   [ Fr( ~suppID ) ]
  --[ SupplicantCreated( ~suppID ) ]->
   [ !Supplicant( ~suppID ), Out( ~suppID ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Auth_Create[color=#ddb4ff]:
   [ Fr( ~authID ), Fr( ~pointerGTKState ), Fr( ~x ) ]
  --[
  AuthenticatorCreated( ~authID ),
  AuthenticatorInstalledGTK( ~authID, <GTK(~x), <N('1'), ~authID>, '4'> ),
  AuthenticatorSetsShareGTK( ~authID, <GTK(~x), <N('1'), ~authID>, '4'> ),
  AllocateUnique( ~pointerGTKState, ~authID )
  ]->
   [
   !Authenticator( ~authID ),
   !L_AuthGTKState( ~authID, 'SETKEYSDONE',
                    <GTK(~x), <N('1'), ~authID>, '4'>, <GTK(~x), <N('1'), ~authID>, '4'>,
                    ~pointerGTKState
   ),
   AuthInstalledGTK( ~authID, <GTK(~x), <N('1'), ~authID>, '4'> ),
   Out( ~authID )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Auth_Associate_With_Supp:
   [
   Fr( ~PMK ), Fr( ~authThreadID ), Fr( ~suppThreadID ),
   Fr( ~authReceiverPtkID ), Fr( ~suppReceiverPtkID ),
   Fr( ~pointerAuthPTK ), Fr( ~pointerSuppPTK ), Fr( ~nullGTKID ),
   !Authenticator( ~authID ), !Supplicant( ~suppID )
   ]
  --[
  Init( ~PMK ),
  Associate( ~authID, ~authThreadID, ~suppID, ~suppThreadID, ~PMK )
  ]->
   [
   AuthState( ~authThreadID, 'INIT_R1_SA',
              <~authID, ~PMK, ~suppThreadID, KDF(<'NULL', 'NULL', 'NULL'>), 
               'NULL_ANonce', 'NULL_SNonce', S('0')>
   ),
   SuppState( ~suppThreadID, 'INIT_R1_SA',
              <~suppID, ~PMK, ~authThreadID, KDF(<'NULL', 'NULL', 'NULL'>), 
               <GTK('NULL'), <N('NULL'), 'NULL'>, 'NULL'>, 'NULL_ANonce', 
               'NULL_SNonce', S('NULL')>
   ),
   !PairwiseMasterKey( ~PMK, ~authID, ~authThreadID, ~suppID, ~suppThreadID
   ),
   !AuthReceiverPTK( ~authReceiverPtkID, ~authThreadID, ~authID,
                     KDF(<'NULL', 'NULL', 'NULL'>), ~pointerAuthPTK
   ),
   !SuppReceiverPTK( ~suppReceiverPtkID, ~suppThreadID, ~suppID,
                     KDF(<'NULL', 'NULL', 'NULL'>), ~pointerSuppPTK
   ),
   ReceiverGTK( ~suppThreadID, ~nullGTKID, ~PMK, GTK('NULL'),
                <N('NULL'), 'NULL'>, 'NULL'
   ),
   Out( ~authThreadID ), Out( ~suppThreadID )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) sendPTKEncryptedPayload_Auth[color=#ffd447]:
   [
   AuthSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(n), ~senderID, 'DF'>
   )
   ]
  --[
  EncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                    KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
  ),
  AuthEncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                        KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
  ),
  SendPTKEncryptedPayload( ~ptkID, ~senderThreadID, ~senderID,
                           KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
  )
  ]->
   [
   Out( snenc(<'data', $message>, KDF(<PMK, ANonce, SNonce>),
              <N(('1'+n)), ~senderID, 'DF'>)
   ),
   AuthSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) sendPTKEncryptedPayload_Supp[color=#ffd447]:
   [
   SuppSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(n), ~senderID, 'DF'>
   )
   ]
  --[
  EncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                    KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
  ),
  SuppEncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                        KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
  ),
  SendPTKEncryptedPayload( ~ptkID, ~senderThreadID, ~senderID,
                           KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
  )
  ]->
   [
   Out( snenc(<'data', $message>, KDF(<PMK, ANonce, SNonce>),
              <N(('1'+n)), ~senderID, 'DF'>)
   ),
   SuppSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) Receive_Clear_Message_Auth[color=#ffffff]:
   [
   In( message ),
   !AuthReceiverPTK( ~ptkID, ~receiverThreadID, ~receiverID,
                     KDF(<'NULL', 'NULL', 'NULL'>), ~pointerPTK
   )
   ]
  --[ Read( ~pointerPTK ) ]->
   [ L_In_Auth( message, ~receiverThreadID, KDF(<'NULL', 'NULL', 'NULL'>) )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Receive_Clear_Message_Supp[color=#ffffff]:
   [
   In( message ),
   !SuppReceiverPTK( ~ptkID, ~receiverThreadID, ~receiverID,
                     KDF(<'NULL', 'NULL', 'NULL'>), ~pointerPTK
   )
   ]
  --[ Read( ~pointerPTK ) ]->
   [ L_In_Supp( message, ~receiverThreadID, KDF(<'NULL', 'NULL', 'NULL'>) )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Receive_Encrypted_Message_Auth[color=#ffd447]:
   [
   In( snenc(message, KDF(<PMK, ANonce, SNonce>),
             <N(n), senderID, frameType>)
   ),
   !AuthReceiverPTK( ~ptkID, ~receiverThreadID, ~receiverID,
                     KDF(<PMK, ANonce, SNonce>), ~pointerPTK
   )[no_precomp]
   ]
  --[
  Neq( KDF(<PMK, ANonce, SNonce>), KDF(<'NULL', 'NULL', 'NULL'>) ),
  SeesNonceForPTK( ~ptkID, ~receiverThreadID, KDF(<PMK, ANonce, SNonce>),
                   <N(n), senderID, frameType>
  ),
  Read( ~pointerPTK )
  ]->
   [ L_In_Auth( message, ~receiverThreadID, KDF(<PMK, ANonce, SNonce>) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Receive_Encrypted_Message_Supp[color=#ffd447]:
   [
   In( snenc(message, KDF(<PMK, ANonce, SNonce>),
             <N(n), senderID, frameType>)
   ),
   !SuppReceiverPTK( ~ptkID, ~receiverThreadID, ~receiverID,
                     KDF(<PMK, ANonce, SNonce>), ~pointerPTK
   )[no_precomp]
   ]
  --[
  Neq( KDF(<PMK, ANonce, SNonce>), KDF(<'NULL', 'NULL', 'NULL'>) ),
  SeesNonceForPTK( ~ptkID, ~receiverThreadID, KDF(<PMK, ANonce, SNonce>),
                   <N(n), senderID, frameType>
  ),
  Read( ~pointerPTK )
  ]->
   [ L_In_Supp( message, ~receiverThreadID, KDF(<PMK, ANonce, SNonce>) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) receiveGTKEncryptedPayload[color=#fcac86]:
   [
   In( snenc(<'data', $message>, GTK(x), <N(m), senderID>) ),
   ReceiverGTK( ~receiverThreadID, ~keyID, ~PMK, GTK(x), <N(n), senderID>,
                $index
   )[no_precomp]
   ]
  --[
  ReceiveGTKEncryptedPayload( ~keyID, ~receiverThreadID, ~PMK, GTK(x),
                              <N(m), senderID>
  ),
  SeesNonceForGTK( ~keyID, ~receiverThreadID, GTK(x), <N(m), senderID> ),
  Neq( $index, 'NULL' )
  ]->
   [
   ReceiverGTK( ~receiverThreadID, ~keyID, ~PMK, GTK(x), <N(m), senderID>,
                $index
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) sendGTKEncryptedPayload_1[color=#fcac86]:
   [
   AuthInstalledGTK( ~authID, <GTK(~x), <N(n), ~authID>, $index> ),
   !L_AuthGTKState( ~authID, stateIdentifier,
                    <GTK(~x), <N(n), ~authID>, $index>, <GTK(~x), <N(n), ~authID>, $index>,
                    ~oldPointerGTKState
   )[no_precomp],
   Fr( ~newPointerGTKState )
   ]
  --[
  EncryptedWithGTK( ~authID, <GTK(~x), <N(('1'+n)), ~authID>, $index>,
                    <GTK(~x), <N(('1'+n)), ~authID>, $index>
  ),
  AuthenticatorUsesGTK( ~authID, <GTK(~x), <N(('1'+n)), ~authID>, $index>,
                        <GTK(~x), <N(n), ~authID>, $index>
  ),
  SendGTKEncryptedPayload( ~authID,
                           <GTK(~x), <N(('1'+n)), ~authID>, $index>,
                           <GTK(~x), <N(('1'+n)), ~authID>, $index>
  ),
  AllocateUnique( ~newPointerGTKState, ~authID ),
  Free( ~oldPointerGTKState )
  ]->
   [
   Out( snenc(<'data', $message>, GTK(~x), <N(('1'+n)), ~authID>) ),
   AuthInstalledGTK( ~authID, <GTK(~x), <N(('1'+n)), ~authID>, $index> ),
   !L_AuthGTKState( ~authID, stateIdentifier,
                    <GTK(~x), <N(('1'+n)), ~authID>, $index>,
                    <GTK(~x), <N(('1'+n)), ~authID>, $index>, ~newPointerGTKState
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) sendGTKEncryptedPayload_2[color=#fcac86]:
   [
   AuthInstalledGTK( ~authID, <GTK(~x), <N(n), ~authID>, $index> ),
   !L_AuthGTKState( ~authID, stateIdentifier,
                    <GTK(~x), <N(n), ~authID>, $index>,
                    <shareGTK, shareGTKNonce, $shareIndex>, ~oldPointerGTKState
   )[no_precomp],
   Fr( ~newPointerGTKState )
   ]
  --[
  EncryptedWithGTK( ~authID, <GTK(~x), <N(('1'+n)), ~authID>, $index>,
                    <shareGTK, shareGTKNonce, $shareIndex>
  ),
  AuthenticatorUsesGTK( ~authID, <GTK(~x), <N(('1'+n)), ~authID>, $index>,
                        <shareGTK, shareGTKNonce, $shareIndex>
  ),
  SendGTKEncryptedPayload( ~authID,
                           <GTK(~x), <N(('1'+n)), ~authID>, $index>,
                           <shareGTK, shareGTKNonce, $shareIndex>
  ),
  AllocateUnique( ~newPointerGTKState, ~authID ),
  AllocateUnique( ~newPointerGTKState, ~authID ),
  Free( ~oldPointerGTKState ), Neq( GTK(~x), shareGTK )
  ]->
   [
   Out( snenc(<'data', $message>, GTK(~x), <N(('1'+n)), ~authID>) ),
   AuthInstalledGTK( ~authID, <GTK(~x), <N(('1'+n)), ~authID>, $index> ),
   !L_AuthGTKState( ~authID, stateIdentifier,
                    <GTK(~x), <N(('1'+n)), ~authID>, $index>,
                    <shareGTK, shareGTKNonce, $shareIndex>, ~newPointerGTKState
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) KeyRevealFromNonceReuse[color=#aa0000]:
   [ In( <snenc(m1, key, nonce), snenc(m2, key, nonce)> )[+] ]
  --[ Neq( m1, m2 ), NonceReuse( key, nonce ) ]->
   [ Out( key ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) KeyRevealPMK[color=#ffffff]:
   [
   !PairwiseMasterKey( ~PMK, ~authID, ~authThreadID, ~suppID, ~suppThreadID
   )
   ]
  --[
  RevealPMK( ~PMK ),
  RevealPMKFor( ~PMK, ~authID, ~authThreadID, ~suppID, ~suppThreadID )
  ]->
   [ Out( ~PMK ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Auth_Snd_M1[color=#ddb4ff]:
   [
   AuthState( ~authThreadID, 'INIT_R1_SA',
              <~authID, ~PMK, ~suppThreadID, KDF(<PMK1, ANonce1, SNonce1>), oldANonce, 
               oldSNonce, S(ctr_minus_1)>
   ),
   Fr( ~ANonce ), Fr( ~messageID )
   ]
  --[
  AuthenticatorSendsM1( ~authThreadID, ~authID, ~PMK, ~suppThreadID,
                        KDF(<PMK1, ANonce1, SNonce1>), ~ANonce, oldSNonce, S(S(ctr_minus_1))
  ),
  EnqueueMessage( ~authThreadID, ~messageID )
  ]->
   [
   AuthState( ~authThreadID, 'PTK_START',
              <~authID, ~PMK, ~suppThreadID, KDF(<PMK1, ANonce1, SNonce1>), ~ANonce, 
               oldSNonce, S(S(ctr_minus_1))>
   ),
   !UsedCounterInPTKHandshake( ~authThreadID, ~ANonce, S(S(ctr_minus_1)) ),
   Out_Auth_Snd_M1( <S(S(ctr_minus_1)), ~ANonce>, ~authThreadID, ~messageID
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) OutRule_Enc_Auth_Snd_M1[color=#ffd447]:
   [
   Out_Auth_Snd_M1( message, ~senderThreadID, ~messageID ),
   AuthSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(n), ~senderID, 'DF'>
   )
   ]
  --[
  EncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                    KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
  ),
  AuthEncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                        KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
  ),
  SendMessage( ~senderThreadID, ~messageID )
  ]->
   [
   Out( snenc(message, KDF(<PMK, ANonce, SNonce>),
              <N(('1'+n)), ~senderID, 'DF'>)
   ),
   AuthSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
   )
   ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

rule (modulo E) OutRule_Auth_Snd_M1[color=#ffffff]:
   [ Out_Auth_Snd_M1( message, ~senderThreadID, ~messageID ) ]
  --[ SendMessage( ~senderThreadID, ~messageID ) ]->
   [ Out( message ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Auth_Snd_M1_repeat[color=#ddb4ff]:
   [
   AuthState( ~authThreadID, 'PTK_START',
              <~authID, ~PMK, ~suppThreadID, KDF(<PMK1, ANonce1, SNonce1>), ~ANonce, 
               oldSNonce, S(ctr_minus_1)>
   ),
   Fr( ~messageID )
   ]
  --[
  AuthenticatorSendsM1Again( ~authThreadID, ~authID, ~PMK, ~suppThreadID,
                             KDF(<PMK1, ANonce1, SNonce1>), ~ANonce, oldSNonce, S(S(ctr_minus_1))
  ),
  EnqueueMessage( ~authThreadID, ~messageID )
  ]->
   [
   AuthState( ~authThreadID, 'PTK_START',
              <~authID, ~PMK, ~suppThreadID, KDF(<PMK1, ANonce1, SNonce1>), ~ANonce, 
               oldSNonce, S(S(ctr_minus_1))>
   ),
   !UsedCounterInPTKHandshake( ~authThreadID, ~ANonce, S(S(ctr_minus_1)) ),
   Out_Auth_Snd_M1_repeat( <S(S(ctr_minus_1)), ~ANonce>, ~authThreadID,
                           ~messageID
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) OutRule_Enc_Auth_Snd_M1_repeat[color=#ffd447]:
   [
   Out_Auth_Snd_M1_repeat( message, ~senderThreadID, ~messageID ),
   AuthSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(n), ~senderID, 'DF'>
   )
   ]
  --[
  EncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                    KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
  ),
  AuthEncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                        KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
  ),
  SendMessage( ~senderThreadID, ~messageID )
  ]->
   [
   Out( snenc(message, KDF(<PMK, ANonce, SNonce>),
              <N(('1'+n)), ~senderID, 'DF'>)
   ),
   AuthSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
   )
   ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

rule (modulo E) OutRule_Auth_Snd_M1_repeat[color=#ffffff]:
   [ Out_Auth_Snd_M1_repeat( message, ~senderThreadID, ~messageID ) ]
  --[ SendMessage( ~senderThreadID, ~messageID ) ]->
   [ Out( message ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Auth_Rcv_M2[color=#ddb4ff]:
   [
   AuthState( ~authThreadID, 'PTK_START',
              <~authID, ~PMK, ~suppThreadID, KDF(<PMK1, ANonce1, SNonce1>), ~ANonce, 
               oldSNonce, S(ctr_minus_1)>
   ),
   L_In_Auth( <<S(ctr_minus_1), SNonce>, mic_m2>, ~authThreadID,
              KDF(<PMK1, ANonce1, SNonce1>)
   )[no_precomp]
   ]
  --[
  AuthenticatorReceivesM2( ~authThreadID, ~authID, ~PMK, ~suppThreadID,
                           KDF(<PMK1, ANonce1, SNonce1>), ~ANonce, SNonce, S(ctr_minus_1)
  )
  ]->
   [
   AuthState( ~authThreadID, 'PTK_CALC_NEGOTIATING',
              <~authID, ~PMK, ~suppThreadID, KDF(<PMK1, ANonce1, SNonce1>), ~ANonce, 
               SNonce, S(ctr_minus_1), <S(ctr_minus_1), SNonce>, mic_m2>
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) Auth_Rcv_M2_repeat[color=#ddb4ff]:
   [
   AuthState( ~authThreadID, 'PTK_CALC_NEGOTIATING',
              <~authID, ~PMK, ~suppThreadID, KDF(<PMK1, ANonce1, SNonce1>), ~ANonce, 
               oldSNonce, S(ctr_minus_1), <S(previous_ctr_minus_1), SNonce>, 
               previous_mic_m2>
   ),
   L_In_Auth( <<S(ctr_minus_1), SNonce>, mic_m2>, ~authThreadID,
              KDF(<PMK1, ANonce1, SNonce1>)
   )[no_precomp]
   ]
  --[
  AuthenticatorReceivesM2Again( ~authThreadID, ~authID, ~PMK,
                                ~suppThreadID, KDF(<PMK1, ANonce1, SNonce1>), ~ANonce, SNonce,
                                S(ctr_minus_1)
  )
  ]->
   [
   AuthState( ~authThreadID, 'PTK_CALC_NEGOTIATING',
              <~authID, ~PMK, ~suppThreadID, KDF(<PMK1, ANonce1, SNonce1>), ~ANonce, 
               SNonce, S(ctr_minus_1), <S(ctr_minus_1), SNonce>, mic_m2>
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) Auth_Check_MIC_M2_Snd_M3[color=#ddb4ff]:
   [
   AuthState( ~authThreadID, 'PTK_CALC_NEGOTIATING',
              <~authID, ~PMK, ~suppThreadID, KDF(<PMK1, ANonce1, SNonce1>), ~ANonce, 
               SNonce, S(ctr_minus_1), <S(ctr_minus_1), SNonce>, mic_m2>
   ),
   !L_AuthGTKState( ~authID, stateIdentifier, installedGTKData,
                    <GTK(~x), <N(n), ~authID>, $index>, ~pointerGTKState
   )[no_precomp],
   Fr( ~messageID )
   ]
  --[
  Eq( mic_m2, MIC(KDF(<~PMK, ~ANonce, SNonce>), <S(ctr_minus_1), SNonce>)
  ),
  AuthenticatorSendsInitialM3( ~authThreadID, ~authID, ~PMK, ~suppThreadID,
                               KDF(<PMK1, ANonce1, SNonce1>), ~ANonce, SNonce, S(S(ctr_minus_1))
  ),
  AuthenticatorRunning( ~authThreadID, ~suppThreadID, ~PMK, ~ANonce,
                        SNonce, KDF(<~PMK, ~ANonce, SNonce>)
  ),
  AuthenticatorUsesGTK( ~authID, installedGTKData,
                        <GTK(~x), <N(n), ~authID>, $index>
  ),
  AuthenticatorSharesGTK( ~authThreadID, ~authID, ~PMK,
                          <GTK(~x), <N(n), ~authID>, $index>
  ),
  ReadUnique( ~pointerGTKState, ~authID ),
  EnqueueMessage( ~authThreadID, ~messageID )
  ]->
   [
   AuthState( ~authThreadID, 'PTK_CALC_NEGOTIATING3',
              <~authID, ~PMK, ~suppThreadID, KDF(<PMK1, ANonce1, SNonce1>), ~ANonce, 
               SNonce, S(S(ctr_minus_1))>
   ),
   !UsedCounterInPTKHandshake( ~authThreadID, ~ANonce, S(S(ctr_minus_1)) ),
   Out_Auth_Check_MIC_M2_Snd_M3( <
                                  <S(S(ctr_minus_1)), 
                                   senc(<GTK(~x), <N(n), ~authID>, $index>, KDF(<~PMK, ~ANonce, SNonce>))>, 
                                  MIC(KDF(<~PMK, ~ANonce, SNonce>),
                                      <S(S(ctr_minus_1)), 
                                       senc(<GTK(~x), <N(n), ~authID>, $index>, KDF(<~PMK, ~ANonce, SNonce>))
                                      >)
                                 >,
                                 ~authThreadID, ~messageID
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) OutRule_Enc_Auth_Check_MIC_M2_Snd_M3[color=#ffd447]:
   [
   Out_Auth_Check_MIC_M2_Snd_M3( message, ~senderThreadID, ~messageID ),
   AuthSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(n), ~senderID, 'DF'>
   )
   ]
  --[
  EncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                    KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
  ),
  AuthEncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                        KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
  ),
  SendMessage( ~senderThreadID, ~messageID )
  ]->
   [
   Out( snenc(message, KDF(<PMK, ANonce, SNonce>),
              <N(('1'+n)), ~senderID, 'DF'>)
   ),
   AuthSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
   )
   ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

rule (modulo E) OutRule_Auth_Check_MIC_M2_Snd_M3[color=#ffffff]:
   [ Out_Auth_Check_MIC_M2_Snd_M3( message, ~senderThreadID, ~messageID ) ]
  --[ SendMessage( ~senderThreadID, ~messageID ) ]->
   [ Out( message ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Auth_Snd_M3_repeat[color=#ddb4ff]:
   [
   AuthState( ~authThreadID, 'PTK_CALC_NEGOTIATING3',
              <~authID, ~PMK, ~suppThreadID, KDF(<PMK1, ANonce1, SNonce1>), ~ANonce, 
               SNonce, S(ctr_minus_1)>
   ),
   !L_AuthGTKState( ~authID, stateIdentifier, installedGTKData,
                    <GTK(~x), <N(n), ~authID>, $index>, ~pointerGTKState
   )[no_precomp],
   Fr( ~messageID )
   ]
  --[
  AuthenticatorSendsM3Again( ~authThreadID, ~authID, ~PMK, ~suppThreadID,
                             KDF(<PMK1, ANonce1, SNonce1>), ~ANonce, SNonce, S(S(ctr_minus_1))
  ),
  AuthenticatorUsesGTK( ~authID, installedGTKData,
                        <GTK(~x), <N(n), ~authID>, $index>
  ),
  AuthenticatorSharesGTK( ~authThreadID, ~authID, ~PMK,
                          <GTK(~x), <N(n), ~authID>, $index>
  ),
  ReadUnique( ~pointerGTKState, ~authID ),
  EnqueueMessage( ~authThreadID, ~messageID )
  ]->
   [
   AuthState( ~authThreadID, 'PTK_CALC_NEGOTIATING3',
              <~authID, ~PMK, ~suppThreadID, KDF(<PMK1, ANonce1, SNonce1>), ~ANonce, 
               SNonce, S(S(ctr_minus_1))>
   ),
   !UsedCounterInPTKHandshake( ~authThreadID, ~ANonce, S(S(ctr_minus_1)) ),
   Out_Auth_Snd_M3_repeat( <
                            <S(S(ctr_minus_1)), 
                             senc(<GTK(~x), <N(n), ~authID>, $index>, KDF(<~PMK, ~ANonce, SNonce>))>, 
                            MIC(KDF(<~PMK, ~ANonce, SNonce>),
                                <S(S(ctr_minus_1)), 
                                 senc(<GTK(~x), <N(n), ~authID>, $index>, KDF(<~PMK, ~ANonce, SNonce>))>)
                           >,
                           ~authThreadID, ~messageID
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) OutRule_Enc_Auth_Snd_M3_repeat[color=#ffd447]:
   [
   Out_Auth_Snd_M3_repeat( message, ~senderThreadID, ~messageID ),
   AuthSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(n), ~senderID, 'DF'>
   )
   ]
  --[
  EncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                    KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
  ),
  AuthEncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                        KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
  ),
  SendMessage( ~senderThreadID, ~messageID )
  ]->
   [
   Out( snenc(message, KDF(<PMK, ANonce, SNonce>),
              <N(('1'+n)), ~senderID, 'DF'>)
   ),
   AuthSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
   )
   ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

rule (modulo E) OutRule_Auth_Snd_M3_repeat[color=#ffffff]:
   [ Out_Auth_Snd_M3_repeat( message, ~senderThreadID, ~messageID ) ]
  --[ SendMessage( ~senderThreadID, ~messageID ) ]->
   [ Out( message ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Auth_Rcv_M4_Install_Key[color=#ddb4ff]:
   [
   AuthState( ~authThreadID, 'PTK_CALC_NEGOTIATING3',
              <~authID, ~PMK, ~suppThreadID, KDF(<PMK1, ANonce1, SNonce1>), ~ANonce, 
               SNonce, S(ctr_minus_1)>
   ),
   !AuthReceiverPTK( ~oldReceiverPtkID, ~authThreadID, ~authID,
                     KDF(<PMK1, ANonce1, SNonce1>), ~oldPointerPTK
   )[no_precomp],
   L_In_Auth( <S(ctr_m4_minus_1), mic_m4>, ~authThreadID,
              KDF(<PMK1, ANonce1, SNonce1>)
   )[-, no_precomp],
   !UsedCounterInPTKHandshake( ~authThreadID, ~ANonce, S(ctr_m4_minus_1)
   )[-],
   Fr( ~dataFramePtkID ), Fr( ~managementFramePtkID ),
   Fr( ~newReceiverPtkID ), Fr( ~gtkID ), Fr( ~counter ),
   Fr( ~newPointerPTK )
   ]
  --[
  AuthenticatorInstalled( ~authThreadID, ~authID, ~PMK, ~suppThreadID,
                          KDF(<~PMK, ~ANonce, SNonce>), ~ANonce, SNonce, S(ctr_minus_1)
  ),
  AuthenticatorCommit( ~authThreadID, ~suppThreadID, ~PMK, ~ANonce, SNonce,
                       KDF(<~PMK, ~ANonce, SNonce>)
  ),
  AuthInstalledSenderPTK( ~dataFramePtkID, ~authThreadID, ~authID,
                          KDF(<~PMK, ~ANonce, SNonce>), <N('1'), ~authID, 'DF'>
  ),
  AuthInstalledSenderPTK( ~managementFramePtkID, ~authThreadID, ~authID,
                          KDF(<~PMK, ~ANonce, SNonce>), <N('1'), ~authID, 'MF'>
  ),
  Eq( mic_m4, MIC(KDF(<~PMK, ~ANonce, SNonce>), S(ctr_m4_minus_1)) ),
  Free( ~oldPointerPTK )
  ]->
   [
   AuthState( ~authThreadID, 'PTK_INIT_DONE',
              <~authID, ~PMK, ~suppThreadID, KDF(<~PMK, ~ANonce, SNonce>), ~ANonce, 
               SNonce, S(~counter)>
   ),
   AuthStartWNMSleepModeThread( ~authThreadID, ~authID, ~PMK,
                                KDF(<PMK1, ANonce1, SNonce1>)
   ),
   AuthSenderPTK( ~dataFramePtkID, ~authThreadID, ~authID,
                  KDF(<~PMK, ~ANonce, SNonce>), <N('1'), ~authID, 'DF'>
   ),
   AuthSenderPTK( ~managementFramePtkID, ~authThreadID, ~authID,
                  KDF(<~PMK, ~ANonce, SNonce>), <N('1'), ~authID, 'MF'>
   ),
   !AuthReceiverPTK( ~newReceiverPtkID, ~authThreadID, ~authID,
                     KDF(<~PMK, ~ANonce, SNonce>), ~newPointerPTK
   )
   ]

  // loop breaker: [3]
  /* has exactly the trivial AC variant */

rule (modulo E) Auth_Rekey_PTK[color=#a333ff]:
   [
   AuthState( ~authThreadID, 'PTK_INIT_DONE',
              <~authID, ~PMK, ~suppThreadID, KDF(<~PMK, ~ANonce, SNonce>), ~ANonce, 
               SNonce, S(ctr_minus_1)>
   )
   ]
  --[
  AuthenticatorRekeyPTK( ~authThreadID, ~authID, ~PMK, ~suppThreadID,
                         KDF(<~PMK, ~ANonce, SNonce>), ~ANonce, SNonce, S(ctr_minus_1)
  )
  ]->
   [
   AuthState( ~authThreadID, 'INIT_R1_SA',
              <~authID, ~PMK, ~suppThreadID, KDF(<~PMK, ~ANonce, SNonce>), ~ANonce, 
               SNonce, S(ctr_minus_1)>
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Supp_Rcv_M1_Snd_M2[color=#b5d1ff]:
   [
   SuppState( ~suppThreadID, 'INIT_R1_SA',
              <~suppID, ~PMK, ~authThreadID, KDF(<PMK1, ANonce1, SNonce1>), 
               <GTK(x), <N(n), authID>, $index>, oldANonce, oldSNonce, S(oldCtr_minus_1)
              >
   ),
   L_In_Supp( <S(ctr_m1_minus_1), ANonce>, ~suppThreadID,
              KDF(<PMK1, ANonce1, SNonce1>)
   )[no_precomp],
   Fr( ~SNonce ), Fr( ~messageID )
   ]
  --[
  SupplicantReceivesM1( ~suppThreadID, ~suppID, ~PMK, ~authThreadID,
                        KDF(<PMK1, ANonce1, SNonce1>), GTK(x), ANonce, ~SNonce, S(ctr_m1_minus_1)
  ),
  SupplicantSeesCounter( ~suppThreadID, ~PMK, S(ctr_m1_minus_1) ),
  EnqueueMessage( ~suppThreadID, ~messageID )
  ]->
   [
   SuppState( ~suppThreadID, 'PTK_START',
              <~suppID, ~PMK, ~authThreadID, KDF(<PMK1, ANonce1, SNonce1>), 
               <GTK(x), <N(n), authID>, $index>, ANonce, ~SNonce, S(ctr_m1_minus_1)>
   ),
   Out_Supp_Rcv_M1_Snd_M2( <<S(ctr_m1_minus_1), ~SNonce>, 
                            MIC(KDF(<~PMK, ANonce, ~SNonce>), <S(ctr_m1_minus_1), ~SNonce>)>,
                           ~suppThreadID, ~messageID
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) OutRule_Enc_Supp_Rcv_M1_Snd_M2[color=#ffd447]:
   [
   Out_Supp_Rcv_M1_Snd_M2( message, ~senderThreadID, ~messageID ),
   SuppSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(n), ~senderID, 'DF'>
   )
   ]
  --[
  EncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                    KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
  ),
  SuppEncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                        KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
  ),
  SendMessage( ~senderThreadID, ~messageID )
  ]->
   [
   Out( snenc(message, KDF(<PMK, ANonce, SNonce>),
              <N(('1'+n)), ~senderID, 'DF'>)
   ),
   SuppSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
   )
   ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

rule (modulo E) OutRule_Supp_Rcv_M1_Snd_M2[color=#ffffff]:
   [ Out_Supp_Rcv_M1_Snd_M2( message, ~senderThreadID, ~messageID ) ]
  --[ SendMessage( ~senderThreadID, ~messageID ) ]->
   [ Out( message ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Supp_Rcv_M1_Snd_M2_repeat[color=#b5d1ff]:
   [
   SuppState( ~suppThreadID, 'PTK_START',
              <~suppID, ~PMK, ~authThreadID, KDF(<PMK1, ANonce1, SNonce1>), 
               <GTK(x), <N(n), authID>, $index>, ANonce, ~SNonce, S(ctr_minus_1_prev)>
   ),
   L_In_Supp( <S(ctr_rercv_m1_minus_1), ANonce>, ~suppThreadID,
              KDF(<PMK1, ANonce1, SNonce1>)
   )[no_precomp],
   Fr( ~messageID )
   ]
  --[
  SupplicantReceivesM1Again( ~suppThreadID, ~suppID, ~PMK, ~authThreadID,
                             KDF(<PMK1, ANonce1, SNonce1>), GTK(x), ANonce, ~SNonce,
                             S(ctr_rercv_m1_minus_1)
  ),
  SupplicantSeesCounter( ~suppThreadID, ~PMK, S(ctr_rercv_m1_minus_1) ),
  EnqueueMessage( ~suppThreadID, ~messageID )
  ]->
   [
   SuppState( ~suppThreadID, 'PTK_START',
              <~suppID, ~PMK, ~authThreadID, KDF(<PMK1, ANonce1, SNonce1>), 
               <GTK(x), <N(n), authID>, $index>, ANonce, ~SNonce, 
               S(ctr_rercv_m1_minus_1)>
   ),
   Out_Supp_Rcv_M1_Snd_M2_repeat( <<S(ctr_rercv_m1_minus_1), ~SNonce>, 
                                   MIC(KDF(<~PMK, ANonce, ~SNonce>), <S(ctr_rercv_m1_minus_1), ~SNonce>)>,
                                  ~suppThreadID, ~messageID
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) OutRule_Enc_Supp_Rcv_M1_Snd_M2_repeat[color=#ffd447]:
   [
   Out_Supp_Rcv_M1_Snd_M2_repeat( message, ~senderThreadID, ~messageID ),
   SuppSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(n), ~senderID, 'DF'>
   )
   ]
  --[
  EncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                    KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
  ),
  SuppEncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                        KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
  ),
  SendMessage( ~senderThreadID, ~messageID )
  ]->
   [
   Out( snenc(message, KDF(<PMK, ANonce, SNonce>),
              <N(('1'+n)), ~senderID, 'DF'>)
   ),
   SuppSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
   )
   ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

rule (modulo E) OutRule_Supp_Rcv_M1_Snd_M2_repeat[color=#ffffff]:
   [ Out_Supp_Rcv_M1_Snd_M2_repeat( message, ~senderThreadID, ~messageID ) ]
  --[ SendMessage( ~senderThreadID, ~messageID ) ]->
   [ Out( message ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Supp_Rcv_M3[color=#b5d1ff]:
   [
   SuppState( ~suppThreadID, 'PTK_START',
              <~suppID, ~PMK, ~authThreadID, KDF(<PMK1, ANonce1, SNonce1>), 
               <GTK(y), <N(m), authID2>, $oldIndex>, ANonce, ~SNonce, S(ctr_minus_1)>
   ),
   L_In_Supp( <
               <S(ctr_m3_minus_1), 
                senc(<GTK(x), <N(n), authID1>, $newIndex>, KDF(<~PMK, ANonce, ~SNonce>))
               >, 
               mic_m3>,
              ~suppThreadID, KDF(<PMK1, ANonce1, SNonce1>)
   )[no_precomp]
   ]
  --[
  SupplicantReceivesM3( ~suppThreadID, ~suppID, ~PMK, ~authThreadID,
                        KDF(<PMK1, ANonce1, SNonce1>), GTK(x), ANonce, ~SNonce, S(ctr_m3_minus_1)
  ),
  SupplicantSeesCounter( ~suppThreadID, ~PMK, S(ctr_m3_minus_1) ),
  Eq( mic_m3,
      MIC(KDF(<~PMK, ANonce, ~SNonce>),
          <S(ctr_m3_minus_1), 
           senc(<GTK(x), <N(n), authID1>, $newIndex>, KDF(<~PMK, ANonce, ~SNonce>))
          >)
  )
  ]->
   [
   SuppState( ~suppThreadID, 'PTK_CALC_NEGOTIATING',
              <~suppID, ~PMK, ~authThreadID, KDF(<PMK1, ANonce1, SNonce1>), 
               <GTK(y), <N(m), authID2>, $oldIndex>, 
               <GTK(x), <N(n), authID1>, $newIndex>, ANonce, ~SNonce, S(ctr_m3_minus_1)>
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) Supp_Install_Key_Snd_M4[color=#b5d1ff]:
   [
   SuppState( ~suppThreadID, 'PTK_CALC_NEGOTIATING',
              <~suppID, ~PMK, ~authThreadID, KDF(<PMK1, ANonce1, SNonce1>), 
               <GTK(y), <N(m), authID2>, $oldIndex>, 
               <GTK(x), <N(n), authID1>, $newIndex>, ANonce, ~SNonce, S(ctr_m3_minus_1)>
   ),
   ReceiverGTK( ~suppThreadID, ~oldGTKID, ~PMK, GTK(y), <N(m), authID2>,
                $oldIndex
   ),
   Fr( ~newGTKID ), Fr( ~messageID )
   ]
  --[
  SupplicantSendsM4( ~suppThreadID, ~suppID, ~PMK, ~authThreadID,
                     KDF(<~PMK, ANonce, ~SNonce>), GTK(x), ANonce, ~SNonce
  ),
  SupplicantInstalledGTK( ~newGTKID, ~suppThreadID, ~PMK, GTK(x),
                          <N(n), authID1>, $newIndex
  ),
  SupplicantRunning( ~suppThreadID, ~authThreadID, ~PMK, ANonce, ~SNonce,
                     KDF(<~PMK, ANonce, ~SNonce>)
  ),
  SupplicantCommit( ~suppThreadID, ~authThreadID, ~PMK, ANonce, ~SNonce,
                    KDF(<~PMK, ANonce, ~SNonce>)
  ),
  SeesNonceForGTK( ~newGTKID, ~suppThreadID, GTK(x), <N(n), authID1> ),
  EnqueueMessage( ~suppThreadID, ~messageID ), Neq( GTK(y), GTK(x) )
  ]->
   [
   SuppState( ~suppThreadID, 'PTK_INIT_DONE',
              <~suppID, ~PMK, ~authThreadID, KDF(<~PMK, ANonce, ~SNonce>), 
               <GTK(x), <N(n), authID1>, $newIndex>, ANonce, ~SNonce, S(ctr_m3_minus_1)>
   ),
   Out_Supp_Install_Key_Snd_M4( <S(ctr_m3_minus_1), 
                                 MIC(KDF(<~PMK, ANonce, ~SNonce>), S(ctr_m3_minus_1))>,
                                ~suppThreadID, ~messageID
   ),
   SuppInstallPTKCommand( ~suppThreadID, ~suppID, ~PMK,
                          KDF(<~PMK, ANonce, ~SNonce>), KDF(<PMK1, ANonce1, SNonce1>), GTK(x),
                          ANonce, ~SNonce
   ),
   ReceiverGTK( ~suppThreadID, ~newGTKID, ~PMK, GTK(x), <N(n), authID1>,
                $newIndex
   )
   ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

rule (modulo E) OutRule_Enc_Supp_Install_Key_Snd_M4[color=#ffd447]:
   [
   Out_Supp_Install_Key_Snd_M4( message, ~senderThreadID, ~messageID ),
   SuppSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(n), ~senderID, 'DF'>
   )
   ]
  --[
  EncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                    KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
  ),
  SuppEncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                        KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
  ),
  SendMessage( ~senderThreadID, ~messageID )
  ]->
   [
   Out( snenc(message, KDF(<PMK, ANonce, SNonce>),
              <N(('1'+n)), ~senderID, 'DF'>)
   ),
   SuppSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
   )
   ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

rule (modulo E) OutRule_Supp_Install_Key_Snd_M4[color=#ffffff]:
   [ Out_Supp_Install_Key_Snd_M4( message, ~senderThreadID, ~messageID ) ]
  --[ SendMessage( ~senderThreadID, ~messageID ) ]->
   [ Out( message ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Supp_Install_PTK[color=#ffc300]:
   [
   Fr( ~dataFramePtkID ), Fr( ~managementFramePtkID ),
   Fr( ~newReceiverPtkID ), Fr( ~pointerNewRcvPTK ),
   SuppInstallPTKCommand( ~suppThreadID, ~suppID, ~PMK,
                          KDF(<~PMK, ANonce, ~SNonce>), KDF(<PMK1, ANonce1, SNonce1>), GTK(x),
                          ANonce, ~SNonce
   ),
   !SuppReceiverPTK( ~oldReceiverPtkID, ~suppThreadID, ~suppID,
                     KDF(<PMK1, ANonce1, SNonce1>), ~pointerOldRcvPTK
   )[no_precomp]
   ]
  --[
  SupplicantInstalledPTK( ~suppThreadID, ~suppID, ~PMK,
                          KDF(<~PMK, ANonce, ~SNonce>), <N('1'), ~suppID, 'DF'>,
                          <N('1'), ~suppID, 'MF'>, GTK(x), ANonce, ~SNonce
  ),
  SuppInstalledSenderPTK( ~dataFramePtkID, ~suppThreadID, ~suppID,
                          KDF(<~PMK, ANonce, ~SNonce>), <N('1'), ~suppID, 'DF'>
  ),
  SuppInstalledSenderPTK( ~managementFramePtkID, ~suppThreadID, ~suppID,
                          KDF(<~PMK, ANonce, ~SNonce>), <N('1'), ~suppID, 'MF'>
  ),
  Free( ~pointerOldRcvPTK ),
  Neq( KDF(<PMK1, ANonce1, SNonce1>), KDF(<~PMK, ANonce, ~SNonce>) )
  ]->
   [
   SuppSenderPTK( ~dataFramePtkID, ~suppThreadID, ~suppID,
                  KDF(<~PMK, ANonce, ~SNonce>), <N('1'), ~suppID, 'DF'>
   ),
   SuppSenderPTK( ~managementFramePtkID, ~suppThreadID, ~suppID,
                  KDF(<~PMK, ANonce, ~SNonce>), <N('1'), ~suppID, 'MF'>
   ),
   !SuppReceiverPTK( ~newReceiverPtkID, ~suppThreadID, ~suppID,
                     KDF(<~PMK, ANonce, ~SNonce>), ~pointerNewRcvPTK
   ),
   SuppStartWNMSleepModeThread( ~suppThreadID, ~suppID, ~PMK,
                                KDF(<PMK1, ANonce1, SNonce1>)
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Supp_Rcv_M3_repeat[color=#b5d1ff]:
   [
   SuppState( ~suppThreadID, 'PTK_INIT_DONE',
              <~suppID, ~PMK, ~authThreadID, KDF(<PMK1, ANonce1, SNonce1>), 
               <GTK(y), <N(m), authID2>, $oldIndex>, ANonce, ~SNonce, S(ctr_minus_1)>
   ),
   L_In_Supp( <
               <S(ctr_m3_minus_1), 
                senc(<GTK(x), <N(n), authID1>, $newIndex>, KDF(<~PMK, ANonce, ~SNonce>))
               >, 
               mic_m3>,
              ~suppThreadID, KDF(<PMK1, ANonce1, SNonce1>)
   )[no_precomp]
   ]
  --[
  SupplicantReceivesM3Again( ~suppThreadID, ~suppID, ~PMK, ~authThreadID,
                             KDF(<PMK1, ANonce1, SNonce1>), GTK(x), ANonce, ~SNonce, S(ctr_m3_minus_1)
  ),
  SuppRcvM3AgainOrGroupRekey( ~suppThreadID, ~suppID, ~PMK, ~authThreadID,
                              KDF(<PMK1, ANonce1, SNonce1>), GTK(x), ANonce, ~SNonce, S(ctr_m3_minus_1)
  ),
  SupplicantSeesCounter( ~suppThreadID, ~PMK, S(ctr_m3_minus_1) ),
  Eq( mic_m3,
      MIC(KDF(<~PMK, ANonce, ~SNonce>),
          <S(ctr_m3_minus_1), 
           senc(<GTK(x), <N(n), authID1>, $newIndex>, KDF(<~PMK, ANonce, ~SNonce>))
          >)
  )
  ]->
   [
   SuppState( ~suppThreadID, 'PTK_CALC_NEGOTIATING',
              <~suppID, ~PMK, ~authThreadID, KDF(<PMK1, ANonce1, SNonce1>), 
               <GTK(y), <N(m), authID2>, $oldIndex>, 
               <GTK(x), <N(n), authID1>, $newIndex>, ANonce, ~SNonce, S(ctr_m3_minus_1)>
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) Supp_Rekey_PTK[color=#3381ff]:
   [
   SuppState( ~suppThreadID, 'PTK_INIT_DONE',
              <~suppID, ~PMK, ~authThreadID, KDF(<PMK1, ANonce1, SNonce1>), 
               <GTK(x), <N(n), authID>, $index>, ANonce, ~SNonce, S(ctr_minus_1)>
   )
   ]
  --[
  SupplicantRekeyPTK( ~suppThreadID, ~suppID, ~PMK,
                      KDF(<PMK1, ANonce1, SNonce1>), GTK(x), ANonce, ~SNonce, S(ctr_minus_1)
  )
  ]->
   [
   SuppState( ~suppThreadID, 'INIT_R1_SA',
              <~suppID, ~PMK, ~authThreadID, KDF(<PMK1, ANonce1, SNonce1>), 
               <GTK(x), <N(n), authID>, $index>, ANonce, ~SNonce, S(ctr_minus_1)>
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Supp_Rekey_GroupKey[color=#3381ff]:
   [
   SuppState( ~suppThreadID, 'PTK_INIT_DONE',
              <~suppID, ~PMK, ~authThreadID, KDF(<PMK1, ANonce1, SNonce1>), 
               <GTK(y), <N(m), authID2>, $oldIndex>, ANonce, ~SNonce, S(ctr_minus_1)>
   ),
   L_In_Supp( <
               <S(ctr_rekey_minus_1), 
                senc(<GTK(x), <N(n), authID1>, $newIndex>, KDF(<PMK1, ANonce1, SNonce1>))
               >, 
               mic>,
              ~suppThreadID, KDF(<PMK1, ANonce1, SNonce1>)
   )[no_precomp],
   ReceiverGTK( ~suppThreadID, ~oldGTKID, ~PMK, GTK(y), <N(m), authID2>,
                $oldIndex
   ),
   Fr( ~newGTKID ), Fr( ~messageID )
   ]
  --[
  Eq( mic,
      MIC(KDF(<PMK1, ANonce1, SNonce1>),
          <S(ctr_rekey_minus_1), 
           senc(<GTK(x), <N(n), authID1>, $newIndex>, KDF(<PMK1, ANonce1, SNonce1>))
          >)
  ),
  SupplicantGroupKeyRekey( ~suppThreadID, ~suppID, ~PMK, ~authThreadID,
                           KDF(<PMK1, ANonce1, SNonce1>), GTK(y), GTK(x), ANonce, ~SNonce,
                           S(ctr_rekey_minus_1)
  ),
  SuppRcvM3AgainOrGroupRekey( ~suppThreadID, ~suppID, ~PMK, ~authThreadID,
                              KDF(<PMK1, ANonce1, SNonce1>), GTK(x), ANonce, ~SNonce,
                              S(ctr_rekey_minus_1)
  ),
  SupplicantSeesCounter( ~suppThreadID, ~PMK, S(ctr_rekey_minus_1) ),
  SupplicantInstalledGTK( ~newGTKID, ~suppThreadID, ~PMK, GTK(x),
                          <N(n), authID1>, $newIndex
  ),
  SeesNonceForGTK( ~newGTKID, ~suppThreadID, GTK(x), <N(n), authID1> ),
  EnqueueMessage( ~suppThreadID, ~messageID ), Neq( GTK(y), GTK(x) )
  ]->
   [
   SuppState( ~suppThreadID, 'PTK_INIT_DONE',
              <~suppID, ~PMK, ~authThreadID, KDF(<PMK1, ANonce1, SNonce1>), 
               <GTK(x), <N(n), authID1>, $newIndex>, ANonce, ~SNonce, 
               S(ctr_rekey_minus_1)>
   ),
   ReceiverGTK( ~suppThreadID, ~newGTKID, ~PMK, GTK(x), <N(n), authID1>,
                $newIndex
   ),
   Out_Supp_Rekey_GroupKey( <S(ctr_rekey_minus_1), 
                             MIC(KDF(<PMK1, ANonce1, SNonce1>), S(ctr_rekey_minus_1))>,
                            ~suppThreadID, ~messageID
   )
   ]

  // loop breakers: [0,2]
  /* has exactly the trivial AC variant */

rule (modulo E) OutRule_Enc_Supp_Rekey_GroupKey[color=#ffd447]:
   [
   Out_Supp_Rekey_GroupKey( message, ~senderThreadID, ~messageID ),
   SuppSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(n), ~senderID, 'DF'>
   )
   ]
  --[
  EncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                    KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
  ),
  SuppEncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                        KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
  ),
  SendMessage( ~senderThreadID, ~messageID )
  ]->
   [
   Out( snenc(message, KDF(<PMK, ANonce, SNonce>),
              <N(('1'+n)), ~senderID, 'DF'>)
   ),
   SuppSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
   )
   ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

rule (modulo E) OutRule_Supp_Rekey_GroupKey[color=#ffffff]:
   [ Out_Supp_Rekey_GroupKey( message, ~senderThreadID, ~messageID ) ]
  --[ SendMessage( ~senderThreadID, ~messageID ) ]->
   [ Out( message ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Auth_Start_GroupKey_Rekey_4[color=#7e2eff]:
   [
   !L_AuthGTKState( ~authID, state_identifier,
                    <installedGTK, installedGTKNonce, '5'>, shareGTKData, ~oldPointerGTKState
   )[no_precomp],
   Fr( ~newPointerGTKState ), Fr( ~x )
   ]
  --[
  AuthenticatorStartsGTKRekey( ~authID,
                               <installedGTK, installedGTKNonce, '5'>, shareGTKData,
                               <GTK(~x), <N('1'), ~authID>, '4'>
  ),
  AuthenticatorUsesGTK( ~authID, <installedGTK, installedGTKNonce, '5'>,
                        shareGTKData
  ),
  AuthenticatorSetsShareGTK( ~authID, <GTK(~x), <N('1'), ~authID>, '4'> ),
  AllocateUnique( ~newPointerGTKState, ~authID ),
  Free( ~oldPointerGTKState )
  ]->
   [
   !L_AuthGTKState( ~authID, 'SETKEYS',
                    <installedGTK, installedGTKNonce, '5'>,
                    <GTK(~x), <N('1'), ~authID>, '4'>, ~newPointerGTKState
   ),
   AuthInstallGTKCommand( ~authID, <GTK(~x), <N('1'), ~authID>, '4'> )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Auth_Start_GroupKey_Rekey_5[color=#7e2eff]:
   [
   !L_AuthGTKState( ~authID, state_identifier,
                    <installedGTK, installedGTKNonce, '4'>, shareGTKData, ~oldPointerGTKState
   )[no_precomp],
   Fr( ~newPointerGTKState ), Fr( ~x )
   ]
  --[
  AuthenticatorStartsGTKRekey( ~authID,
                               <installedGTK, installedGTKNonce, '4'>, shareGTKData,
                               <GTK(~x), <N('1'), ~authID>, '5'>
  ),
  AuthenticatorUsesGTK( ~authID, <installedGTK, installedGTKNonce, '4'>,
                        shareGTKData
  ),
  AuthenticatorSetsShareGTK( ~authID, <GTK(~x), <N('1'), ~authID>, '5'> ),
  AllocateUnique( ~newPointerGTKState, ~authID ),
  Free( ~oldPointerGTKState )
  ]->
   [
   !L_AuthGTKState( ~authID, 'SETKEYS',
                    <installedGTK, installedGTKNonce, '4'>,
                    <GTK(~x), <N('1'), ~authID>, '5'>, ~newPointerGTKState
   ),
   AuthInstallGTKCommand( ~authID, <GTK(~x), <N('1'), ~authID>, '5'> )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Auth_Rekey_GroupKey_Init[color=#a333ff]:
   [
   AuthState( ~authThreadID, 'PTK_INIT_DONE',
              <~authID, ~PMK, ~suppThreadID, KDF(<PMK1, ANonce1, SNonce1>), ~ANonce, 
               SNonce, S(ctr_minus_1)>
   ),
   !L_AuthGTKState( ~authID, 'SETKEYS', installedGTKData,
                    <GTK(~x), <N('1'), ~authID>, $shareGTKIndex>, ~pointerGTKState
   )[no_precomp],
   Fr( ~messageID )
   ]
  --[
  AuthenticatorInitsGroupKeyRekey( ~authThreadID, ~authID, ~PMK,
                                   ~suppThreadID, KDF(<PMK1, ANonce1, SNonce1>), ~ANonce, SNonce,
                                   S(S(ctr_minus_1)), <GTK(~x), <N('1'), ~authID>, $shareGTKIndex>
  ),
  AuthenticatorUsesGTK( ~authID, installedGTKData,
                        <GTK(~x), <N('1'), ~authID>, $shareGTKIndex>
  ),
  AuthenticatorSharesGTK( ~authThreadID, ~authID, ~PMK,
                          <GTK(~x), <N('1'), ~authID>, $shareGTKIndex>
  ),
  ReadUnique( ~pointerGTKState, ~authID ),
  EnqueueMessage( ~authThreadID, ~messageID )
  ]->
   [
   AuthState( ~authThreadID, 'REKEYNEGOTIATING',
              <~authID, ~PMK, ~suppThreadID, KDF(<PMK1, ANonce1, SNonce1>), ~ANonce, 
               SNonce, S(S(ctr_minus_1)), GTK(~x), <N('1'), ~authID>, $shareGTKIndex>
   ),
   !UsedCounterInGTKHandshake( ~authThreadID,
                               <GTK(~x), <N('1'), ~authID>, $shareGTKIndex>, S(S(ctr_minus_1))
   ),
   Out_Auth_Rekey_GroupKey_Init( <
                                  <S(S(ctr_minus_1)), 
                                   senc(<GTK(~x), <N('1'), ~authID>, $shareGTKIndex>,
                                        KDF(<PMK1, ANonce1, SNonce1>))
                                  >, 
                                  MIC(KDF(<PMK1, ANonce1, SNonce1>),
                                      <S(S(ctr_minus_1)), 
                                       senc(<GTK(~x), <N('1'), ~authID>, $shareGTKIndex>,
                                            KDF(<PMK1, ANonce1, SNonce1>))
                                      >)
                                 >,
                                 ~authThreadID, ~messageID
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) OutRule_Enc_Auth_Rekey_GroupKey_Init[color=#ffd447]:
   [
   Out_Auth_Rekey_GroupKey_Init( message, ~senderThreadID, ~messageID ),
   AuthSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(n), ~senderID, 'DF'>
   )
   ]
  --[
  EncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                    KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
  ),
  AuthEncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                        KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
  ),
  SendMessage( ~senderThreadID, ~messageID )
  ]->
   [
   Out( snenc(message, KDF(<PMK, ANonce, SNonce>),
              <N(('1'+n)), ~senderID, 'DF'>)
   ),
   AuthSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
   )
   ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

rule (modulo E) OutRule_Auth_Rekey_GroupKey_Init[color=#ffffff]:
   [ Out_Auth_Rekey_GroupKey_Init( message, ~senderThreadID, ~messageID ) ]
  --[ SendMessage( ~senderThreadID, ~messageID ) ]->
   [ Out( message ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Auth_Rekey_GroupKey_Init_repeat[color=#a333ff]:
   [
   AuthState( ~authThreadID, 'REKEYNEGOTIATING',
              <~authID, ~PMK, ~suppThreadID, KDF(<PMK1, ANonce1, SNonce1>), ~ANonce, 
               SNonce, S(ctr_minus_1), GTK(~x), <N('1'), ~authID>, $shareGTKIndex>
   ),
   !L_AuthGTKState( ~authID, 'SETKEYS', installedGTKData,
                    <GTK(~x), <N('1'), ~authID>, $shareGTKIndex>, ~pointerGTKState
   )[no_precomp],
   Fr( ~messageID )
   ]
  --[
  AuthenticatorInitsGroupKeyRekeyAgain( ~authThreadID, ~authID, ~PMK,
                                        ~suppThreadID, KDF(<PMK1, ANonce1, SNonce1>), ~ANonce, SNonce,
                                        S(S(ctr_minus_1)), <GTK(~x), <N('1'), ~authID>, $shareGTKIndex>
  ),
  AuthenticatorUsesGTK( ~authID, installedGTKData,
                        <GTK(~x), <N('1'), ~authID>, $shareGTKIndex>
  ),
  AuthenticatorSharesGTK( ~authThreadID, ~authID, ~PMK,
                          <GTK(~x), <N('1'), ~authID>, $shareGTKIndex>
  ),
  ReadUnique( ~pointerGTKState, ~authID ),
  EnqueueMessage( ~authThreadID, ~messageID )
  ]->
   [
   AuthState( ~authThreadID, 'REKEYNEGOTIATING',
              <~authID, ~PMK, ~suppThreadID, KDF(<PMK1, ANonce1, SNonce1>), ~ANonce, 
               SNonce, S(S(ctr_minus_1)), GTK(~x), <N('1'), ~authID>, $shareGTKIndex>
   ),
   !UsedCounterInGTKHandshake( ~authThreadID,
                               <GTK(~x), <N('1'), ~authID>, $shareGTKIndex>, S(S(ctr_minus_1))
   ),
   Out_Auth_Rekey_GroupKey_Init_repeat( <
                                         <S(S(ctr_minus_1)), 
                                          senc(<GTK(~x), <N('1'), ~authID>, $shareGTKIndex>,
                                               KDF(<PMK1, ANonce1, SNonce1>))
                                         >, 
                                         MIC(KDF(<PMK1, ANonce1, SNonce1>),
                                             <S(S(ctr_minus_1)), 
                                              senc(<GTK(~x), <N('1'), ~authID>, $shareGTKIndex>,
                                                   KDF(<PMK1, ANonce1, SNonce1>))
                                             >)
                                        >,
                                        ~authThreadID, ~messageID
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) OutRule_Enc_Auth_Rekey_GroupKey_Init_repeat[color=#ffd447]:
   [
   Out_Auth_Rekey_GroupKey_Init_repeat( message, ~senderThreadID, ~messageID
   ),
   AuthSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(n), ~senderID, 'DF'>
   )
   ]
  --[
  EncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                    KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
  ),
  AuthEncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                        KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
  ),
  SendMessage( ~senderThreadID, ~messageID )
  ]->
   [
   Out( snenc(message, KDF(<PMK, ANonce, SNonce>),
              <N(('1'+n)), ~senderID, 'DF'>)
   ),
   AuthSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'DF'>
   )
   ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

rule (modulo E) OutRule_Auth_Rekey_GroupKey_Init_repeat[color=#ffffff]:
   [
   Out_Auth_Rekey_GroupKey_Init_repeat( message, ~senderThreadID, ~messageID
   )
   ]
  --[ SendMessage( ~senderThreadID, ~messageID ) ]->
   [ Out( message ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Auth_Deauthenticate_Supplicant[color=#a333ff]:
   [
   AuthState( ~authThreadID, 'REKEYNEGOTIATING',
              <~authID, ~PMK, ~suppThreadID, PTK, ~ANonce, SNonce, ctr, shareGTKData>
   )
   ]
  --[
  AuthenticatorDeauthenticatesSupplicant( ~authThreadID, ~authID, ~PMK,
                                          ~suppThreadID, shareGTKData
  ),
  AuthenticatorThreadFinishesGTKRekey( ~authThreadID, ~authID, ~PMK,
                                       ~suppThreadID, PTK, ~ANonce, SNonce, ctr, shareGTKData
  )
  ]->
   [
   AuthState( ~authThreadID, 'KEYERROR',
              <~authID, ~PMK, ~suppThreadID, PTK, ~ANonce, SNonce, ctr, shareGTKData>
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Auth_Rekey_GroupKey_Finished[color=#a333ff]:
   [
   AuthState( ~authThreadID, 'REKEYNEGOTIATING',
              <~authID, ~PMK, ~suppThreadID, KDF(<PMK1, ANonce1, SNonce1>), ~ANonce, 
               SNonce, S(ctr_minus_1), GTK(~x), <N('1'), ~authID>, $shareGTKIndex>
   ),
   L_In_Auth( <S(ctr_response_minus_1), 
               MIC(KDF(<PMK1, ANonce1, SNonce1>), S(ctr_response_minus_1))>,
              ~authThreadID, KDF(<PMK1, ANonce1, SNonce1>)
   )[no_precomp],
   !UsedCounterInGTKHandshake( ~authThreadID,
                               <GTK(~x), <N('1'), ~authID>, $shareGTKIndex>, S(ctr_response_minus_1)
   )[-]
   ]
  --[
  AuthenticatorThreadFinishesGTKRekey( ~authThreadID, ~authID, ~PMK,
                                       ~suppThreadID, KDF(<PMK1, ANonce1, SNonce1>), ~ANonce, SNonce,
                                       S(ctr_minus_1), <GTK(~x), <N('1'), ~authID>, $shareGTKIndex>
  )
  ]->
   [
   AuthState( ~authThreadID, 'PTK_INIT_DONE',
              <~authID, ~PMK, ~suppThreadID, KDF(<PMK1, ANonce1, SNonce1>), ~ANonce, 
               SNonce, S(ctr_minus_1)>
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Auth_Install_GroupKey[color=#ff9563]:
   [
   AuthInstallGTKCommand( ~authID,
                          <GTK(~x), <N('1'), ~authID>, $shareGTKIndex>
   ),
   !L_AuthGTKState( ~authID, 'SETKEYS',
                    <GTK(~x), <N(n), ~authID>, $installedGTKIndex>,
                    <GTK(~x), <N('1'), ~authID>, $shareGTKIndex>, ~oldPointerGTKState
   )[no_precomp],
   AuthInstalledGTK( ~authID, <GTK(~x), <N(n), ~authID>, $installedGTKIndex>
   )[+],
   Fr( ~newPointerGTKState )
   ]
  --[
  AuthenticatorInstalledGTK( ~authID,
                             <GTK(~x), <N('1'), ~authID>, $shareGTKIndex>
  ),
  AllocateUnique( ~newPointerGTKState, ~authID ),
  Free( ~oldPointerGTKState )
  ]->
   [
   AuthInstalledGTK( ~authID, <GTK(~x), <N('1'), ~authID>, $shareGTKIndex>
   ),
   !L_AuthGTKState( ~authID, 'SETKEYS',
                    <GTK(~x), <N('1'), ~authID>, $shareGTKIndex>,
                    <GTK(~x), <N('1'), ~authID>, $shareGTKIndex>, ~newPointerGTKState
   )
   ]

  // loop breaker: [2]
  /* has exactly the trivial AC variant */

rule (modulo E) Auth_Start_WNM_Sleep_Mode_Thread[color=#ff7afd]:
   [
   AuthStartWNMSleepModeThread( ~authThreadID, ~authID, ~PMK,
                                KDF(<'NULL', 'NULL', 'NULL'>)
   )
   ]
  --[ AuthenticatorStartsWNMSleepModeThread( ~authThreadID, ~authID, ~PMK )
  ]->
   [ AuthWNMState( ~authThreadID, 'WNM_STATE', ~authID, ~PMK ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Auth_WNM_Accept_Awake_Request[color=#ffb4fe]:
   [
   AuthWNMState( ~authThreadID, 'WNM_STATE', ~authID, ~PMK ),
   !L_AuthGTKState( ~authID, stateIdentifier, installedGTKData,
                    <GTK(~x), <N(n), ~authID>, $shareGTKIndex>, ~pointerGTKState
   )[no_precomp],
   L_In_Auth( 'REQUEST_AWAKE', ~authThreadID, KDF(<~PMK, ANonce, SNonce>)
   )[no_precomp],
   Fr( ~messageID )
   ]
  --[
  AuthenticatorAcceptsAwakeRequest( ~authThreadID, ~authID ),
  AuthenticatorUsesGTK( ~authID, installedGTKData,
                        <GTK(~x), <N(n), ~authID>, $shareGTKIndex>
  ),
  AuthenticatorSharesGTK( ~authThreadID, ~authID, ~PMK,
                          <GTK(~x), <N(n), ~authID>, $shareGTKIndex>
  ),
  AuthenticatorAcceptsWNMRequest( ~authThreadID, ~authID, ~PMK ),
  AuthenticatorReceivesAwakeOK( ~authThreadID,
                                <'ACCEPT_AWAKE', GTK(~x), <N(n), ~authID>, $shareGTKIndex>
  ),
  ReadUnique( ~pointerGTKState, ~authID ),
  EnqueueMessage( ~authThreadID, ~messageID )
  ]->
   [
   Out_Auth_WNM_Accept_Awake_Request( <'ACCEPT_AWAKE', GTK(~x), 
                                       <N(n), ~authID>, $shareGTKIndex>,
                                      ~authThreadID, ~messageID
   ),
   AuthWNMState( ~authThreadID, 'WNM_STATE', ~authID, ~PMK )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) OutRule_Enc_Auth_WNM_Accept_Awake_Request[color=#ffd447]:
   [
   Out_Auth_WNM_Accept_Awake_Request( message, ~senderThreadID, ~messageID
   ),
   AuthSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(n), ~senderID, 'MF'>
   )
   ]
  --[
  EncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                    KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'MF'>
  ),
  AuthEncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                        KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'MF'>
  ),
  SendMessage( ~senderThreadID, ~messageID )
  ]->
   [
   Out( snenc(message, KDF(<PMK, ANonce, SNonce>),
              <N(('1'+n)), ~senderID, 'MF'>)
   ),
   AuthSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'MF'>
   )
   ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

rule (modulo E) Auth_WNM_Accept_Sleep_Request[color=#ffb4fe]:
   [
   AuthWNMState( ~authThreadID, 'WNM_STATE', ~authID, ~PMK ),
   !AuthReceiverPTK( ~receiverPtkID, ~authThreadID, ~authID,
                     KDF(<~PMK, ANonce, SNonce>), ~newPointerPTK
   )[no_precomp],
   L_In_Auth( 'REQUEST_SLEEP', ~authThreadID, KDF(<~PMK, ANonce, SNonce>)
   )[no_precomp],
   Fr( ~messageID )
   ]
  --[
  AuthenticatorAcceptsSleepRequest( ~authThreadID, ~authID ),
  AuthenticatorAcceptsWNMRequest( ~authThreadID, ~authID, ~PMK ),
  AuthenticatorReceivesSleepOK( ~authThreadID, 'ACCEPT_SLEEP' ),
  EnqueueMessage( ~authThreadID, ~messageID )
  ]->
   [
   Out_Auth_WNM_Accept_Sleep_Request( 'ACCEPT_SLEEP', ~authThreadID,
                                      ~messageID
   ),
   AuthWNMState( ~authThreadID, 'WNM_STATE', ~authID, ~PMK )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) OutRule_Enc_Auth_WNM_Accept_Sleep_Request[color=#ffd447]:
   [
   Out_Auth_WNM_Accept_Sleep_Request( message, ~senderThreadID, ~messageID
   ),
   AuthSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(n), ~senderID, 'MF'>
   )
   ]
  --[
  EncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                    KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'MF'>
  ),
  AuthEncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                        KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'MF'>
  ),
  SendMessage( ~senderThreadID, ~messageID )
  ]->
   [
   Out( snenc(message, KDF(<PMK, ANonce, SNonce>),
              <N(('1'+n)), ~senderID, 'MF'>)
   ),
   AuthSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'MF'>
   )
   ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

rule (modulo E) Supp_Start_WNM_Sleep_Mode_Thread[color=#87e1e6]:
   [
   SuppStartWNMSleepModeThread( ~suppThreadID, ~suppID, ~PMK,
                                KDF(<'NULL', 'NULL', 'NULL'>)
   )
   ]
  --[ SupplicantStartsWNMSleepModeThread( ~suppThreadID, ~suppID, ~PMK )
  ]->
   [ SuppWNMState( ~suppThreadID, 'AWAKE', ~suppID, ~PMK ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Supp_Send_WNM_Sleep_Request[color=#87e1e6]:
   [ SuppWNMState( ~suppThreadID, 'AWAKE', ~suppID, ~PMK ), Fr( ~messageID )
   ]
  --[
  SupplicantRequestsSleep( ~suppThreadID, ~suppID, ~PMK ),
  EnqueueMessage( ~suppThreadID, ~messageID )
  ]->
   [
   SuppWNMState( ~suppThreadID, 'AWAIT_SLEEP_CONFIRMATION', ~suppID, ~PMK ),
   Out_Supp_Send_WNM_Sleep_Request( 'REQUEST_SLEEP', ~suppThreadID,
                                    ~messageID
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) OutRule_Enc_Supp_Send_WNM_Sleep_Request[color=#ffd447]:
   [
   Out_Supp_Send_WNM_Sleep_Request( message, ~senderThreadID, ~messageID ),
   SuppSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(n), ~senderID, 'MF'>
   )
   ]
  --[
  EncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                    KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'MF'>
  ),
  SuppEncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                        KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'MF'>
  ),
  SendMessage( ~senderThreadID, ~messageID )
  ]->
   [
   Out( snenc(message, KDF(<PMK, ANonce, SNonce>),
              <N(('1'+n)), ~senderID, 'MF'>)
   ),
   SuppSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'MF'>
   )
   ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

rule (modulo E) Supp_WNM_Receive_Sleep_Accept[color=#87e1e6]:
   [
   SuppWNMState( ~suppThreadID, 'AWAIT_SLEEP_CONFIRMATION', ~suppID, ~PMK ),
   !SuppReceiverPTK( ~receiverPtkID, ~suppThreadID, ~suppID,
                     KDF(<~PMK, ANonce, SNonce>), ~pointerRcvPTK
   )[no_precomp],
   L_In_Supp( 'ACCEPT_SLEEP', ~suppThreadID, KDF(<~PMK, ANonce, SNonce>)
   )[no_precomp],
   Fr( ~nullGTKID ),
   ReceiverGTK( ~suppThreadID, ~oldGTKID, ~PMK, oldGTK, oldGTKNonce,
                $oldIndex
   )[no_precomp]
   ]
  --[
  SupplicantStartsSleep( ~suppThreadID, ~suppID, ~PMK ),
  Read( ~pointerRcvPTK )
  ]->
   [
   SuppWNMState( ~suppThreadID, 'SLEEP', ~suppID, ~PMK ),
   ReceiverGTK( ~suppThreadID, ~nullGTKID, ~PMK, GTK('NULL'),
                <N('NULL'), 'NULL'>, 'NULL'
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) Supp_WNM_Send_Awake_Request[color=#87e1e6]:
   [ SuppWNMState( ~suppThreadID, 'SLEEP', ~suppID, ~PMK ), Fr( ~messageID )
   ]
  --[
  SupplicantRequestsAwake( ~suppThreadID, ~suppID, ~PMK ),
  Enqueue( ~suppThreadID, ~messageID )
  ]->
   [
   SuppWNMState( ~suppThreadID, 'AWAIT_AWAKE_CONFIRMATION', ~suppID, ~PMK ),
   Out_Supp_Send_WNM_Awake_Request( 'REQUEST_AWAKE', ~suppThreadID,
                                    ~messageID
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) OutRule_Enc_Supp_Send_WNM_Awake_Request[color=#ffd447]:
   [
   Out_Supp_Send_WNM_Awake_Request( message, ~senderThreadID, ~messageID ),
   SuppSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(n), ~senderID, 'MF'>
   )
   ]
  --[
  EncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                    KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'MF'>
  ),
  SuppEncryptedWithPTK( ~ptkID, ~senderThreadID, ~senderID,
                        KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'MF'>
  ),
  SendMessage( ~senderThreadID, ~messageID )
  ]->
   [
   Out( snenc(message, KDF(<PMK, ANonce, SNonce>),
              <N(('1'+n)), ~senderID, 'MF'>)
   ),
   SuppSenderPTK( ~ptkID, ~senderThreadID, ~senderID,
                  KDF(<PMK, ANonce, SNonce>), <N(('1'+n)), ~senderID, 'MF'>
   )
   ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

rule (modulo E) Supp_WNM_Receive_Awake_Accept[color=#87e1e6]:
   [
   SuppWNMState( ~suppThreadID, 'AWAIT_AWAKE_CONFIRMATION', ~suppID, ~PMK ),
   !SuppReceiverPTK( ~receiverPtkID, ~suppThreadID, ~suppID,
                     KDF(<~PMK, ANonce, SNonce>), ~pointerRcvPTK
   )[no_precomp],
   L_In_Supp( <'ACCEPT_AWAKE', GTK(x), <N(n), authID>, $newIndex>,
              ~suppThreadID, KDF(<~PMK, ANonce, SNonce>)
   )[no_precomp],
   ReceiverGTK( ~suppThreadID, ~oldGTKID, ~PMK, oldGTK, oldGTKNonce,
                $oldIndex
   ),
   Fr( ~newGTKID )
   ]
  --[
  SupplicantAwakes( ~suppThreadID, ~suppID, ~PMK ),
  SupplicantInstalledGTK( ~newGTKID, ~suppThreadID, ~PMK, GTK(x),
                          <N(n), authID>, $newIndex
  ),
  SeesNonceForGTK( ~newGTKID, ~suppThreadID, GTK(x), <N(n), authID> ),
  Read( ~pointerRcvPTK ), Neq( oldGTK, GTK(x) )
  ]->
   [
   SuppWNMState( ~suppThreadID, 'AWAKE', ~suppID, ~PMK ),
   ReceiverGTK( ~suppThreadID, ~newGTKID, ~PMK, GTK(x), <N(n), authID>,
                $newIndex
   )
   ]

  // loop breaker: [3]
  /* has exactly the trivial AC variant */

lemma nonce_reuse_key_type [sources]:
  all-traces
  "∀ key nonce #i.
    (NonceReuse( key, nonce ) @ #i) ⇒
    (((∃ #j. (#j < #i) ∧ (!KU( key ) @ #j)) ∨ (∃ x. key = GTK(x))) ∨
     (∃ PMK ANonce SNonce. key = KDF(<PMK, ANonce, SNonce>)))"
/*
guarded formula characterizing all counter-examples:
"∃ key nonce #i.
  (NonceReuse( key, nonce ) @ #i)
 ∧
  (∀ #j. (!KU( key ) @ #j) ⇒ ¬(#j < #i)) ∧
  (∀ x. (key = GTK(x)) ⇒ ⊥) ∧
  (∀ PMK ANonce SNonce. (key = KDF(<PMK, ANonce, SNonce>)) ⇒ ⊥)"
*/
by sorry

lemma associated_parties_need_to_be_created [reuse]:
  all-traces
  "∀ authID authThreadID suppID suppThreadID PMK #i.
    (Associate( authID, authThreadID, suppID, suppThreadID, PMK ) @ #i) ⇒
    ((∃ #j. (#j < #i) ∧ (AuthenticatorCreated( authID ) @ #j)) ∧
     (∃ #k. (#k < #i) ∧ (SupplicantCreated( suppID ) @ #k)))"
/*
guarded formula characterizing all counter-examples:
"∃ authID authThreadID suppID suppThreadID PMK #i.
  (Associate( authID, authThreadID, suppID, suppThreadID, PMK ) @ #i)
 ∧
  ((∀ #j. (AuthenticatorCreated( authID ) @ #j) ⇒ ¬(#j < #i)) ∨
   (∀ #k. (SupplicantCreated( suppID ) @ #k) ⇒ ¬(#k < #i)))"
*/
by sorry

lemma association_of_authenticator_with_supplicant_is_unique [reuse]:
  all-traces
  "∀ authID1 authID2 authThreadID suppID1 suppID2 suppThreadID PMK1 PMK2 #i
     #j.
    ((Associate( authID1, authThreadID, suppID1, suppThreadID, PMK1 ) @ #i) ∧
     (Associate( authID2, authThreadID, suppID2, suppThreadID, PMK2 ) @ #j)) ⇒
    (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ authID1 authID2 authThreadID suppID1 suppID2 suppThreadID PMK1 PMK2 #i
   #j.
  (Associate( authID1, authThreadID, suppID1, suppThreadID, PMK1 ) @ #i) ∧
  (Associate( authID2, authThreadID, suppID2, suppThreadID, PMK2 ) @ #j)
 ∧
  ¬(#i = #j)"
*/
by sorry

lemma authenticator_used_ptks_must_be_installed [reuse, use_induction,
                                                 heuristic=S]:
  all-traces
  "∀ ptkID authID authThreadID PTK nonceNumber ptkInstallerID frameType #i.
    (AuthEncryptedWithPTK( ptkID, authThreadID, authID, PTK,
                           <nonceNumber, ptkInstallerID, frameType>
     ) @ #i) ⇒
    (∃ #j.
      ((#j < #i) ∧
       (AuthInstalledSenderPTK( ptkID, authThreadID, authID, PTK,
                                <N('1'), authID, frameType>
        )[+] @ #j)) ∧
      (authID = ptkInstallerID))"
/*
guarded formula characterizing all counter-examples:
"∃ ptkID authID authThreadID PTK nonceNumber ptkInstallerID frameType #i.
  (AuthEncryptedWithPTK( ptkID, authThreadID, authID, PTK,
                         <nonceNumber, ptkInstallerID, frameType>
   ) @ #i)
 ∧
  ∀ #j.
   (AuthInstalledSenderPTK( ptkID, authThreadID, authID, PTK,
                            <N('1'), authID, frameType>
    )[+] @ #j) ∧
   (authID = ptkInstallerID)
  ⇒
   ¬(#j < #i)"
*/
by sorry

lemma supplicant_used_ptks_must_be_installed [reuse, use_induction,
                                              heuristic=S]:
  all-traces
  "∀ ptkID suppID suppThreadID ptkInstallerID PTK nonceNumber frameType #i.
    (SuppEncryptedWithPTK( ptkID, suppThreadID, suppID, PTK,
                           <nonceNumber, ptkInstallerID, frameType>
     ) @ #i) ⇒
    (∃ #j.
      ((#j < #i) ∧
       (SuppInstalledSenderPTK( ptkID, suppThreadID, suppID, PTK,
                                <N('1'), suppID, frameType>
        )[+] @ #j)) ∧
      (suppID = ptkInstallerID))"
/*
guarded formula characterizing all counter-examples:
"∃ ptkID suppID suppThreadID ptkInstallerID PTK nonceNumber frameType #i.
  (SuppEncryptedWithPTK( ptkID, suppThreadID, suppID, PTK,
                         <nonceNumber, ptkInstallerID, frameType>
   ) @ #i)
 ∧
  ∀ #j.
   (SuppInstalledSenderPTK( ptkID, suppThreadID, suppID, PTK,
                            <N('1'), suppID, frameType>
    )[+] @ #j) ∧
   (suppID = ptkInstallerID)
  ⇒
   ¬(#j < #i)"
*/
by sorry

lemma authenticator_use_gtk_must_be_preceded_by_install_gtk [reuse,
                                                             use_induction, heuristic=S]:
  all-traces
  "∀ authID GTK n index shareGTKData #i.
    (AuthenticatorUsesGTK( authID, <GTK, <n, authID>, index>, shareGTKData
     ) @ #i) ⇒
    (∃ #j.
      AuthenticatorInstalledGTK( authID, <GTK, <N('1'), authID>, index>
      ) @ #j)"
/*
guarded formula characterizing all counter-examples:
"∃ authID GTK n index shareGTKData #i.
  (AuthenticatorUsesGTK( authID, <GTK, <n, authID>, index>, shareGTKData
   ) @ #i)
 ∧
  ∀ #j.
   (AuthenticatorInstalledGTK( authID, <GTK, <N('1'), authID>, index>
    ) @ #j)
  ⇒
   ⊥"
*/
by sorry

lemma authenticator_use_gtk_must_be_preceded_by_set_share_gtk [reuse,
                                                               use_induction, heuristic=S]:
  all-traces
  "∀ authID GTK n index installedGTKData #i.
    (AuthenticatorUsesGTK( authID, installedGTKData,
                           <GTK, <n, authID>, index>
     ) @ #i) ⇒
    (∃ #j.
      (#j < #i) ∧
      (AuthenticatorSetsShareGTK( authID, <GTK, <N('1'), authID>, index>
       ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ authID GTK n index installedGTKData #i.
  (AuthenticatorUsesGTK( authID, installedGTKData,
                         <GTK, <n, authID>, index>
   ) @ #i)
 ∧
  ∀ #j.
   (AuthenticatorSetsShareGTK( authID, <GTK, <N('1'), authID>, index>
    ) @ #j)
  ⇒
   ¬(#j < #i)"
*/
by sorry

lemma authenticator_gtk_rekey_must_be_preceded_by_create [reuse,
                                                          use_induction, heuristic=C]:
  all-traces
  "∀ authID installedGTKData shareGTKData newGTKData #i.
    (AuthenticatorStartsGTKRekey( authID, installedGTKData, shareGTKData,
                                  newGTKData
     ) @ #i) ⇒
    (∃ #j. (#j < #i) ∧ (AuthenticatorCreated( authID ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ authID installedGTKData shareGTKData newGTKData #i.
  (AuthenticatorStartsGTKRekey( authID, installedGTKData, shareGTKData,
                                newGTKData
   ) @ #i)
 ∧
  ∀ #j. (AuthenticatorCreated( authID ) @ #j) ⇒ ¬(#j < #i)"
*/
by sorry

lemma authenticator_encryption_gtks_must_be_installed [reuse,
                                                       use_induction, heuristic=C]:
  all-traces
  "∀ authID GTK n index shareGTKData #i.
    (EncryptedWithGTK( authID, <GTK, <n, authID>, index>, shareGTKData
     ) @ #i) ⇒
    (∃ #j.
      (#j < #i) ∧
      (AuthenticatorInstalledGTK( authID, <GTK, <N('1'), authID>, index>
       )[+] @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ authID GTK n index shareGTKData #i.
  (EncryptedWithGTK( authID, <GTK, <n, authID>, index>, shareGTKData
   ) @ #i)
 ∧
  ∀ #j.
   (AuthenticatorInstalledGTK( authID, <GTK, <N('1'), authID>, index>
    )[+] @ #j)
  ⇒
   ¬(#j < #i)"
*/
by sorry

lemma authenticator_must_send_an_initial_m1 [reuse, use_induction]:
  all-traces
  "∀ authThreadID authID PMK suppThreadID PTK ANonce SNonce ctr #i.
    (AuthenticatorSendsM1Again( authThreadID, authID, PMK, suppThreadID, PTK,
                                ANonce, SNonce, ctr
     ) @ #i) ⇒
    (∃ #j prectr.
      (#j < #i) ∧
      (AuthenticatorSendsM1( authThreadID, authID, PMK, suppThreadID, PTK,
                             ANonce, SNonce, prectr
       ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ authThreadID authID PMK suppThreadID PTK ANonce SNonce ctr #i.
  (AuthenticatorSendsM1Again( authThreadID, authID, PMK, suppThreadID, PTK,
                              ANonce, SNonce, ctr
   ) @ #i)
 ∧
  ∀ #j prectr.
   (AuthenticatorSendsM1( authThreadID, authID, PMK, suppThreadID, PTK,
                          ANonce, SNonce, prectr
    ) @ #j)
  ⇒
   ¬(#j < #i)"
*/
by sorry

lemma authenticator_snd_m1_is_unique_for_anonce [reuse]:
  all-traces
  "∀ authThreadID1 authThreadID2 authID1 authID2 PMK1 PMK2 suppThreadID1
     suppThreadID2 PTK1 PTK2 ANonce SNonce1 SNonce2 ctr1 ctr2 #i #j.
    ((AuthenticatorSendsM1( authThreadID1, authID1, PMK1, suppThreadID1,
                            PTK1, ANonce, SNonce1, ctr1
      ) @ #i) ∧
     (AuthenticatorSendsM1( authThreadID2, authID2, PMK2, suppThreadID2, PTK2,
                            ANonce, SNonce2, ctr2
      ) @ #j)) ⇒
    (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ authThreadID1 authThreadID2 authID1 authID2 PMK1 PMK2 suppThreadID1
   suppThreadID2 PTK1 PTK2 ANonce SNonce1 SNonce2 ctr1 ctr2 #i #j.
  (AuthenticatorSendsM1( authThreadID1, authID1, PMK1, suppThreadID1, PTK1,
                         ANonce, SNonce1, ctr1
   ) @ #i) ∧
  (AuthenticatorSendsM1( authThreadID2, authID2, PMK2, suppThreadID2, PTK2,
                         ANonce, SNonce2, ctr2
   ) @ #j)
 ∧
  ¬(#i = #j)"
*/
by sorry

lemma supplicant_must_receive_an_initial_m1 [reuse, use_induction,
                                             heuristic=S]:
  all-traces
  "∀ suppThreadID suppID PMK authThreadID PTK GTK ANonce SNonce ctr #i.
    (SupplicantReceivesM1Again( suppThreadID, suppID, PMK, authThreadID, PTK,
                                GTK, ANonce, SNonce, ctr
     ) @ #i) ⇒
    (∃ prectr #j.
      (#j < #i) ∧
      (SupplicantReceivesM1( suppThreadID, suppID, PMK, authThreadID, PTK, GTK,
                             ANonce, SNonce, prectr
       ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ suppThreadID suppID PMK authThreadID PTK GTK ANonce SNonce ctr #i.
  (SupplicantReceivesM1Again( suppThreadID, suppID, PMK, authThreadID, PTK,
                              GTK, ANonce, SNonce, ctr
   ) @ #i)
 ∧
  ∀ prectr #j.
   (SupplicantReceivesM1( suppThreadID, suppID, PMK, authThreadID, PTK, GTK,
                          ANonce, SNonce, prectr
    ) @ #j)
  ⇒
   ¬(#j < #i)"
*/
by sorry

lemma authenticator_snd_m1_precedes_rcv_m2 [reuse, use_induction,
                                            heuristic=C]:
  all-traces
  "∀ authThreadID authID PMK suppThreadID PTK ANonce oldSNonce SNonce ctr1
     ctr2 #i #j.
    ((AuthenticatorSendsM1Again( authThreadID, authID, PMK, suppThreadID,
                                 PTK, ANonce, oldSNonce, ctr1
      ) @ #i) ∧
     (AuthenticatorReceivesM2( authThreadID, authID, PMK, suppThreadID, PTK,
                               ANonce, SNonce, ctr2
      ) @ #j)) ⇒
    (#i < #j)"
/*
guarded formula characterizing all counter-examples:
"∃ authThreadID authID PMK suppThreadID PTK ANonce oldSNonce SNonce ctr1
   ctr2 #i #j.
  (AuthenticatorSendsM1Again( authThreadID, authID, PMK, suppThreadID, PTK,
                              ANonce, oldSNonce, ctr1
   ) @ #i) ∧
  (AuthenticatorReceivesM2( authThreadID, authID, PMK, suppThreadID, PTK,
                            ANonce, SNonce, ctr2
   ) @ #j)
 ∧
  ¬(#i < #j)"
*/
by sorry

lemma authenticator_must_receive_an_initial_m2 [reuse, use_induction,
                                                heuristic=S]:
  all-traces
  "∀ authThreadID authID PMK suppThreadID PTK ANonce SNonce ctr #i.
    (AuthenticatorReceivesM2Again( authThreadID, authID, PMK, suppThreadID,
                                   PTK, ANonce, SNonce, ctr
     ) @ #i) ⇒
    (∃ #j.
      (#j < #i) ∧
      (AuthenticatorReceivesM2( authThreadID, authID, PMK, suppThreadID, PTK,
                                ANonce, SNonce, ctr
       ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ authThreadID authID PMK suppThreadID PTK ANonce SNonce ctr #i.
  (AuthenticatorReceivesM2Again( authThreadID, authID, PMK, suppThreadID,
                                 PTK, ANonce, SNonce, ctr
   ) @ #i)
 ∧
  ∀ #j.
   (AuthenticatorReceivesM2( authThreadID, authID, PMK, suppThreadID, PTK,
                             ANonce, SNonce, ctr
    ) @ #j)
  ⇒
   ¬(#j < #i)"
*/
by sorry

lemma authenticator_rcv_m2_must_be_preceded_by_snd_m1 [reuse,
                                                       heuristic=S]:
  all-traces
  "∀ authThreadID authID PMK suppThreadID PTK ANonce SNonce ctr #i.
    (AuthenticatorReceivesM2( authThreadID, authID, PMK, suppThreadID, PTK,
                              ANonce, SNonce, ctr
     ) @ #i) ⇒
    (∃ oldSNonce prectr #j.
      (#j < #i) ∧
      (AuthenticatorSendsM1( authThreadID, authID, PMK, suppThreadID, PTK,
                             ANonce, oldSNonce, prectr
       ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ authThreadID authID PMK suppThreadID PTK ANonce SNonce ctr #i.
  (AuthenticatorReceivesM2( authThreadID, authID, PMK, suppThreadID, PTK,
                            ANonce, SNonce, ctr
   ) @ #i)
 ∧
  ∀ oldSNonce prectr #j.
   (AuthenticatorSendsM1( authThreadID, authID, PMK, suppThreadID, PTK,
                          ANonce, oldSNonce, prectr
    ) @ #j)
  ⇒
   ¬(#j < #i)"
*/
by sorry

lemma authenticator_rcv_m2_is_unique_for_anonce [reuse, heuristic=C]:
  all-traces
  "∀ authThreadID1 authThreadID2 authID1 authID2 PMK1 PMK2 suppThreadID1
     suppThreadID2 PTK1 PTK2 ANonce SNonce1 SNonce2 ctr1 ctr2 #i #j.
    ((AuthenticatorReceivesM2( authThreadID1, authID1, PMK1, suppThreadID1,
                               PTK1, ANonce, SNonce1, ctr1
      ) @ #i) ∧
     (AuthenticatorReceivesM2( authThreadID2, authID2, PMK2, suppThreadID2,
                               PTK2, ANonce, SNonce2, ctr2
      ) @ #j)) ⇒
    (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ authThreadID1 authThreadID2 authID1 authID2 PMK1 PMK2 suppThreadID1
   suppThreadID2 PTK1 PTK2 ANonce SNonce1 SNonce2 ctr1 ctr2 #i #j.
  (AuthenticatorReceivesM2( authThreadID1, authID1, PMK1, suppThreadID1,
                            PTK1, ANonce, SNonce1, ctr1
   ) @ #i) ∧
  (AuthenticatorReceivesM2( authThreadID2, authID2, PMK2, suppThreadID2,
                            PTK2, ANonce, SNonce2, ctr2
   ) @ #j)
 ∧
  ¬(#i = #j)"
*/
by sorry

lemma authenticator_must_send_an_initial_m3 [reuse, use_induction,
                                             heuristic=S]:
  all-traces
  "∀ authThreadID authID PMK suppThreadID PTK ANonce SNonce ctr #i.
    (AuthenticatorSendsM3Again( authThreadID, authID, PMK, suppThreadID, PTK,
                                ANonce, SNonce, ctr
     ) @ #i) ⇒
    (∃ prectr #j.
      (#j < #i) ∧
      (AuthenticatorSendsInitialM3( authThreadID, authID, PMK, suppThreadID,
                                    PTK, ANonce, SNonce, prectr
       ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ authThreadID authID PMK suppThreadID PTK ANonce SNonce ctr #i.
  (AuthenticatorSendsM3Again( authThreadID, authID, PMK, suppThreadID, PTK,
                              ANonce, SNonce, ctr
   ) @ #i)
 ∧
  ∀ prectr #j.
   (AuthenticatorSendsInitialM3( authThreadID, authID, PMK, suppThreadID,
                                 PTK, ANonce, SNonce, prectr
    ) @ #j)
  ⇒
   ¬(#j < #i)"
*/
by sorry

lemma authenticator_rercv_m2_precedes_snd_m3 [reuse, use_induction,
                                              heuristic=C]:
  all-traces
  "∀ authThreadID authID PMK suppThreadID PTK ANonce SNonce ctr1 ctr2 #i
     #j.
    ((AuthenticatorReceivesM2Again( authThreadID, authID, PMK, suppThreadID,
                                    PTK, ANonce, SNonce, ctr1
      ) @ #i) ∧
     (AuthenticatorSendsInitialM3( authThreadID, authID, PMK, suppThreadID,
                                   PTK, ANonce, SNonce, ctr2
      ) @ #j)) ⇒
    (#i < #j)"
/*
guarded formula characterizing all counter-examples:
"∃ authThreadID authID PMK suppThreadID PTK ANonce SNonce ctr1 ctr2 #i
   #j.
  (AuthenticatorReceivesM2Again( authThreadID, authID, PMK, suppThreadID,
                                 PTK, ANonce, SNonce, ctr1
   ) @ #i) ∧
  (AuthenticatorSendsInitialM3( authThreadID, authID, PMK, suppThreadID,
                                PTK, ANonce, SNonce, ctr2
   ) @ #j)
 ∧
  ¬(#i < #j)"
*/
by sorry

lemma authenticator_snd_m3_is_unique_for_anonce [reuse, heuristic=S]:
  all-traces
  "∀ authThreadID1 authThreadID2 authID1 authID2 PMK1 PMK2 suppThreadID1
     suppThreadID2 PTK1 PTK2 ANonce SNonce1 SNonce2 ctr1 ctr2 #i #j.
    ((AuthenticatorSendsInitialM3( authThreadID1, authID1, PMK1,
                                   suppThreadID1, PTK1, ANonce, SNonce1, ctr1
      ) @ #i) ∧
     (AuthenticatorSendsInitialM3( authThreadID2, authID2, PMK2,
                                   suppThreadID2, PTK2, ANonce, SNonce2, ctr2
      ) @ #j)) ⇒
    (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ authThreadID1 authThreadID2 authID1 authID2 PMK1 PMK2 suppThreadID1
   suppThreadID2 PTK1 PTK2 ANonce SNonce1 SNonce2 ctr1 ctr2 #i #j.
  (AuthenticatorSendsInitialM3( authThreadID1, authID1, PMK1,
                                suppThreadID1, PTK1, ANonce, SNonce1, ctr1
   ) @ #i) ∧
  (AuthenticatorSendsInitialM3( authThreadID2, authID2, PMK2,
                                suppThreadID2, PTK2, ANonce, SNonce2, ctr2
   ) @ #j)
 ∧
  ¬(#i = #j)"
*/
by sorry

lemma supplicant_rercv_m1_precedes_rcv_m3 [use_induction, reuse,
                                           heuristic=S]:
  all-traces
  "∀ suppThreadID suppID PMK authThreadID PTK ANonce SNonce GTK1 GTK2 ctr2
     ctr1 #i #j.
    ((SupplicantReceivesM3( suppThreadID, suppID, PMK, authThreadID, PTK,
                            GTK1, ANonce, SNonce, ctr2
      ) @ #j) ∧
     (SupplicantReceivesM1Again( suppThreadID, suppID, PMK, authThreadID, PTK,
                                 GTK2, ANonce, SNonce, ctr1
      ) @ #i)) ⇒
    (#i < #j)"
/*
guarded formula characterizing all counter-examples:
"∃ suppThreadID suppID PMK authThreadID PTK ANonce SNonce GTK1 GTK2 ctr2
   ctr1 #i #j.
  (SupplicantReceivesM3( suppThreadID, suppID, PMK, authThreadID, PTK,
                         GTK1, ANonce, SNonce, ctr2
   ) @ #j) ∧
  (SupplicantReceivesM1Again( suppThreadID, suppID, PMK, authThreadID, PTK,
                              GTK2, ANonce, SNonce, ctr1
   ) @ #i)
 ∧
  ¬(#i < #j)"
*/
by sorry

lemma supplicant_rercv_m3_or_gtk_rekey_must_be_preceded_by_rcv_m3 [reuse,
                                                                   use_induction, heuristic=S]:
  all-traces
  "∀ suppThreadID suppID PMK authThreadID PTK GTK ANonce SNonce ctr #i.
    (SuppRcvM3AgainOrGroupRekey( suppThreadID, suppID, PMK, authThreadID,
                                 PTK, GTK, ANonce, SNonce, ctr
     ) @ #i) ⇒
    (∃ prectr ANonce1 SNonce1 PMK1 x #j.
      (#j < #i) ∧
      (SupplicantReceivesM3( suppThreadID, suppID, PMK, authThreadID,
                             KDF(<PMK1, ANonce1, SNonce1>), GTK(x), ANonce, SNonce, prectr
       ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ suppThreadID suppID PMK authThreadID PTK GTK ANonce SNonce ctr #i.
  (SuppRcvM3AgainOrGroupRekey( suppThreadID, suppID, PMK, authThreadID,
                               PTK, GTK, ANonce, SNonce, ctr
   ) @ #i)
 ∧
  ∀ prectr ANonce1 SNonce1 PMK1 x #j.
   (SupplicantReceivesM3( suppThreadID, suppID, PMK, authThreadID,
                          KDF(<PMK1, ANonce1, SNonce1>), GTK(x), ANonce, SNonce, prectr
    ) @ #j)
  ⇒
   ¬(#j < #i)"
*/
by sorry

lemma supplicant_rcv_m1_must_be_preceded_by_associate [reuse,
                                                       use_induction, heuristic=C]:
  all-traces
  "∀ suppThreadID suppID PMK authThreadID PTK GTK ANonce SNonce ctr #i.
    (SupplicantReceivesM1( suppThreadID, suppID, PMK, authThreadID, PTK, GTK,
                           ANonce, SNonce, ctr
     ) @ #i) ⇒
    (∃ authID #j.
      (#j < #i) ∧
      (Associate( authID, authThreadID, suppID, suppThreadID, PMK ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ suppThreadID suppID PMK authThreadID PTK GTK ANonce SNonce ctr #i.
  (SupplicantReceivesM1( suppThreadID, suppID, PMK, authThreadID, PTK, GTK,
                         ANonce, SNonce, ctr
   ) @ #i)
 ∧
  ∀ authID #j.
   (Associate( authID, authThreadID, suppID, suppThreadID, PMK ) @ #j)
  ⇒
   ¬(#j < #i)"
*/
by sorry

lemma supplicant_rcv_m3_must_be_preceded_by_associate [reuse,
                                                       heuristic=S]:
  all-traces
  "∀ suppThreadID suppID PMK authThreadID PTK ANonce SNonce GTK ctr #i.
    (SupplicantReceivesM3( suppThreadID, suppID, PMK, authThreadID, PTK,
                           ANonce, SNonce, GTK, ctr
     ) @ #i) ⇒
    (∃ authID #j.
      Associate( authID, authThreadID, suppID, suppThreadID, PMK ) @ #j)"
/*
guarded formula characterizing all counter-examples:
"∃ suppThreadID suppID PMK authThreadID PTK ANonce SNonce GTK ctr #i.
  (SupplicantReceivesM3( suppThreadID, suppID, PMK, authThreadID, PTK,
                         ANonce, SNonce, GTK, ctr
   ) @ #i)
 ∧
  ∀ authID #j.
   (Associate( authID, authThreadID, suppID, suppThreadID, PMK ) @ #j) ⇒ ⊥"
*/
simplify
solve( SuppState( ~suppThreadID, 'PTK_START',
                  <~suppID, ~PMK, ~authThreadID, KDF(<PMK1, ANonce1, SNonce1>), 
                   <GTK(y), <N(m), authID2>, $oldIndex>, SNonce, ~SNonce.1, S(ctr_minus_1)>
       ) ▶₀ #i )
  case Supp_Rcv_M1_Snd_M2_case_1
  by contradiction /* from formulas */
next
  case Supp_Rcv_M1_Snd_M2_case_2
  by contradiction /* from formulas */
next
  case Supp_Rcv_M1_Snd_M2_case_3
  by contradiction /* from formulas */
next
  case Supp_Rcv_M1_Snd_M2_case_4
  by contradiction /* from formulas */
next
  case Supp_Rcv_M1_Snd_M2_repeat
  by contradiction /* from formulas */
qed

lemma supplicant_initial_rcv_m3_is_unique_for_snonce [reuse,
                                                      heuristic=S]:
  all-traces
  "∀ suppThreadID1 suppThreadID2 suppID1 suppID2 PMK authThreadID1
     authThreadID2 PTK1 PTK2 ANonce1 ANonce2 SNonce GTK1 GTK2 ctr1 ctr2 #i #j.
    ((SupplicantReceivesM3( suppThreadID1, suppID1, PMK, authThreadID1, PTK1,
                            GTK1, ANonce1, SNonce, ctr1
      ) @ #i) ∧
     (SupplicantReceivesM3( suppThreadID2, suppID2, PMK, authThreadID2, PTK2,
                            GTK2, ANonce2, SNonce, ctr2
      ) @ #j)) ⇒
    (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ suppThreadID1 suppThreadID2 suppID1 suppID2 PMK authThreadID1
   authThreadID2 PTK1 PTK2 ANonce1 ANonce2 SNonce GTK1 GTK2 ctr1 ctr2 #i #j.
  (SupplicantReceivesM3( suppThreadID1, suppID1, PMK, authThreadID1, PTK1,
                         GTK1, ANonce1, SNonce, ctr1
   ) @ #i) ∧
  (SupplicantReceivesM3( suppThreadID2, suppID2, PMK, authThreadID2, PTK2,
                         GTK2, ANonce2, SNonce, ctr2
   ) @ #j)
 ∧
  ¬(#i = #j)"
*/
by sorry

lemma supplicant_rercv_m3_or_gtk_rekey_must_be_preceded_by_send_m4 [reuse,
                                                                    use_induction, heuristic=C]:
  all-traces
  "∀ suppThreadID suppID PMK authThreadID PTK ANonce SNonce GTK ctr #i.
    (SuppRcvM3AgainOrGroupRekey( suppThreadID, suppID, PMK, authThreadID,
                                 PTK, GTK, ANonce, SNonce, ctr
     ) @ #i) ⇒
    (∃ x #j.
      (#j < #i) ∧
      (SupplicantSendsM4( suppThreadID, suppID, PMK, authThreadID, PTK, GTK(x),
                          ANonce, SNonce
       ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ suppThreadID suppID PMK authThreadID PTK ANonce SNonce GTK ctr #i.
  (SuppRcvM3AgainOrGroupRekey( suppThreadID, suppID, PMK, authThreadID,
                               PTK, GTK, ANonce, SNonce, ctr
   ) @ #i)
 ∧
  ∀ x #j.
   (SupplicantSendsM4( suppThreadID, suppID, PMK, authThreadID, PTK, GTK(x),
                       ANonce, SNonce
    ) @ #j)
  ⇒
   ¬(#j < #i)"
*/
by sorry

lemma supplicant_send_m4_must_be_preceded_by_rcv_m3 [reuse,
                                                     use_induction, heuristic=S]:
  all-traces
  "∀ suppThreadID suppID PMK authThreadID PTK GTK ANonce SNonce #i.
    (SupplicantSendsM4( suppThreadID, suppID, PMK, authThreadID, PTK, GTK,
                        ANonce, SNonce
     ) @ #i) ⇒
    (∃ prectr PMK1 ANonce1 SNonce1 x #j.
      (#j < #i) ∧
      (SupplicantReceivesM3( suppThreadID, suppID, PMK, authThreadID,
                             KDF(<PMK1, ANonce1, SNonce1>), GTK(x), ANonce, SNonce, prectr
       ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ suppThreadID suppID PMK authThreadID PTK GTK ANonce SNonce #i.
  (SupplicantSendsM4( suppThreadID, suppID, PMK, authThreadID, PTK, GTK,
                      ANonce, SNonce
   ) @ #i)
 ∧
  ∀ prectr PMK1 ANonce1 SNonce1 x #j.
   (SupplicantReceivesM3( suppThreadID, suppID, PMK, authThreadID,
                          KDF(<PMK1, ANonce1, SNonce1>), GTK(x), ANonce, SNonce, prectr
    ) @ #j)
  ⇒
   ¬(#j < #i)"
*/
by sorry

lemma authenticator_snd_m3_rpt_precedes_rcv_m4 [reuse, use_induction,
                                                heuristic=C]:
  all-traces
  "∀ authThreadID authID PMK suppThreadID PTK1 PTK2 ANonce SNonce ctr1 ctr2
     #i #j.
    ((AuthenticatorSendsM3Again( authThreadID, authID, PMK, suppThreadID,
                                 PTK1, ANonce, SNonce, ctr1
      ) @ #i) ∧
     (AuthenticatorInstalled( authThreadID, authID, PMK, suppThreadID, PTK2,
                              ANonce, SNonce, ctr2
      ) @ #j)) ⇒
    (#i < #j)"
/*
guarded formula characterizing all counter-examples:
"∃ authThreadID authID PMK suppThreadID PTK1 PTK2 ANonce SNonce ctr1 ctr2
   #i #j.
  (AuthenticatorSendsM3Again( authThreadID, authID, PMK, suppThreadID,
                              PTK1, ANonce, SNonce, ctr1
   ) @ #i) ∧
  (AuthenticatorInstalled( authThreadID, authID, PMK, suppThreadID, PTK2,
                           ANonce, SNonce, ctr2
   ) @ #j)
 ∧
  ¬(#i < #j)"
*/
by sorry

lemma authenticator_installed_is_unique_for_anonce [reuse, heuristic=S]:
  all-traces
  "∀ authThreadID1 authThreadID2 authID1 authID2 PMK1 PMK2 suppThreadID1
     suppThreadID2 PTK1 PTK2 ANonce SNonce1 SNonce2 ctr1 ctr2 #i #j.
    ((AuthenticatorInstalled( authThreadID1, authID1, PMK1, suppThreadID1,
                              PTK1, ANonce, SNonce1, ctr1
      ) @ #i) ∧
     (AuthenticatorInstalled( authThreadID2, authID2, PMK2, suppThreadID2,
                              PTK2, ANonce, SNonce2, ctr2
      ) @ #j)) ⇒
    (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ authThreadID1 authThreadID2 authID1 authID2 PMK1 PMK2 suppThreadID1
   suppThreadID2 PTK1 PTK2 ANonce SNonce1 SNonce2 ctr1 ctr2 #i #j.
  (AuthenticatorInstalled( authThreadID1, authID1, PMK1, suppThreadID1,
                           PTK1, ANonce, SNonce1, ctr1
   ) @ #i) ∧
  (AuthenticatorInstalled( authThreadID2, authID2, PMK2, suppThreadID2,
                           PTK2, ANonce, SNonce2, ctr2
   ) @ #j)
 ∧
  ¬(#i = #j)"
*/
by sorry

lemma authenticator_wnm_sleep_thread_is_unique [reuse, heuristic=S]:
  all-traces
  "∀ authThreadID authID1 authID2 PMK #i #j.
    ((AuthenticatorStartsWNMSleepModeThread( authThreadID, authID1, PMK
      ) @ #i) ∧
     (AuthenticatorStartsWNMSleepModeThread( authThreadID, authID2, PMK
      ) @ #j)) ⇒
    (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ authThreadID authID1 authID2 PMK #i #j.
  (AuthenticatorStartsWNMSleepModeThread( authThreadID, authID1, PMK
   ) @ #i) ∧
  (AuthenticatorStartsWNMSleepModeThread( authThreadID, authID2, PMK
   ) @ #j)
 ∧
  ¬(#i = #j)"
*/
by sorry

lemma supplicant_wnm_sleep_thread_is_unique [reuse, heuristic=S]:
  all-traces
  "∀ suppThreadID suppID1 suppID2 PMK #i #j.
    ((SupplicantStartsWNMSleepModeThread( suppThreadID, suppID1, PMK
      ) @ #i) ∧
     (SupplicantStartsWNMSleepModeThread( suppThreadID, suppID2, PMK
      ) @ #j)) ⇒
    (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ suppThreadID suppID1 suppID2 PMK #i #j.
  (SupplicantStartsWNMSleepModeThread( suppThreadID, suppID1, PMK ) @ #i) ∧
  (SupplicantStartsWNMSleepModeThread( suppThreadID, suppID2, PMK ) @ #j)
 ∧
  ¬(#i = #j)"
*/
by sorry

lemma authenticator_gtk_init_again_must_be_preceded_by_init [reuse,
                                                             use_induction, heuristic=S]:
  all-traces
  "∀ authThreadID authID PMK suppThreadID PTK ANonce SNonce ctr newGTK #i.
    (AuthenticatorInitsGroupKeyRekeyAgain( authThreadID, authID, PMK,
                                           suppThreadID, PTK, ANonce, SNonce, ctr, newGTK
     ) @ #i) ⇒
    (∃ prectr #j.
      (#j < #i) ∧
      (AuthenticatorInitsGroupKeyRekey( authThreadID, authID, PMK,
                                        suppThreadID, PTK, ANonce, SNonce, prectr, newGTK
       ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ authThreadID authID PMK suppThreadID PTK ANonce SNonce ctr newGTK #i.
  (AuthenticatorInitsGroupKeyRekeyAgain( authThreadID, authID, PMK,
                                         suppThreadID, PTK, ANonce, SNonce, ctr, newGTK
   ) @ #i)
 ∧
  ∀ prectr #j.
   (AuthenticatorInitsGroupKeyRekey( authThreadID, authID, PMK,
                                     suppThreadID, PTK, ANonce, SNonce, prectr, newGTK
    ) @ #j)
  ⇒
   ¬(#j < #i)"
*/
by sorry

lemma authenticator_gtk_init_must_be_preceded_by_installed [reuse,
                                                            use_induction, heuristic=S]:
  all-traces
  "∀ authThreadID authID PMK suppThreadID PTK ANonce SNonce ctr newGTK #i.
    (AuthenticatorInitsGroupKeyRekey( authThreadID, authID, PMK,
                                      suppThreadID, PTK, ANonce, SNonce, ctr, newGTK
     ) @ #i) ⇒
    (∃ prectr #j.
      (#j < #i) ∧
      (AuthenticatorInstalled( authThreadID, authID, PMK, suppThreadID, PTK,
                               ANonce, SNonce, prectr
       ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ authThreadID authID PMK suppThreadID PTK ANonce SNonce ctr newGTK #i.
  (AuthenticatorInitsGroupKeyRekey( authThreadID, authID, PMK,
                                    suppThreadID, PTK, ANonce, SNonce, ctr, newGTK
   ) @ #i)
 ∧
  ∀ prectr #j.
   (AuthenticatorInstalled( authThreadID, authID, PMK, suppThreadID, PTK,
                            ANonce, SNonce, prectr
    ) @ #j)
  ⇒
   ¬(#j < #i)"
*/
by sorry

lemma authenticator_gtk_rekey_finished_must_be_preceded_by_init [reuse]:
  all-traces
  "∀ authThreadID authID PMK suppThreadID PTK ANonce SNonce ctr shareGTK
     #i.
    (AuthenticatorThreadFinishesGTKRekey( authThreadID, authID, PMK,
                                          suppThreadID, PTK, ANonce, SNonce, ctr, shareGTK
     ) @ #i) ⇒
    (∃ prectr #j.
      (#j < #i) ∧
      (AuthenticatorInitsGroupKeyRekey( authThreadID, authID, PMK,
                                        suppThreadID, PTK, ANonce, SNonce, prectr, shareGTK
       ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ authThreadID authID PMK suppThreadID PTK ANonce SNonce ctr shareGTK
   #i.
  (AuthenticatorThreadFinishesGTKRekey( authThreadID, authID, PMK,
                                        suppThreadID, PTK, ANonce, SNonce, ctr, shareGTK
   ) @ #i)
 ∧
  ∀ prectr #j.
   (AuthenticatorInitsGroupKeyRekey( authThreadID, authID, PMK,
                                     suppThreadID, PTK, ANonce, SNonce, prectr, shareGTK
    ) @ #j)
  ⇒
   ¬(#j < #i)"
*/
by sorry

lemma authenticator_gtk_rekey_must_be_preceded_by_send_initial_m3 [reuse,
                                                                   heuristic=S]:
  all-traces
  "∀ authThreadID authID PMK suppThreadID PTK ANonce SNonce newGTK ctr #i.
    (AuthenticatorThreadFinishesGTKRekey( authThreadID, authID, PMK,
                                          suppThreadID, PTK, ANonce, SNonce, ctr, newGTK
     ) @ #i) ⇒
    (∃ PMK1 ANonce1 SNonce1 prectr #j.
      (#j < #i) ∧
      (AuthenticatorSendsInitialM3( authThreadID, authID, PMK, suppThreadID,
                                    KDF(<PMK1, ANonce1, SNonce1>), ANonce, SNonce, prectr
       ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ authThreadID authID PMK suppThreadID PTK ANonce SNonce newGTK ctr #i.
  (AuthenticatorThreadFinishesGTKRekey( authThreadID, authID, PMK,
                                        suppThreadID, PTK, ANonce, SNonce, ctr, newGTK
   ) @ #i)
 ∧
  ∀ PMK1 ANonce1 SNonce1 prectr #j.
   (AuthenticatorSendsInitialM3( authThreadID, authID, PMK, suppThreadID,
                                 KDF(<PMK1, ANonce1, SNonce1>), ANonce, SNonce, prectr
    ) @ #j)
  ⇒
   ¬(#j < #i)"
*/
by sorry

lemma authenticator_installed_must_be_preceded_by_send_initial_m3 [reuse,
                                                                   use_induction, heuristic=S]:
  all-traces
  "∀ authThreadID authID PMK suppThreadID PTK ANonce SNonce ctr #i.
    (AuthenticatorInstalled( authThreadID, authID, PMK, suppThreadID, PTK,
                             ANonce, SNonce, ctr
     ) @ #i) ⇒
    (∃ prePTK prectr #j.
      (#j < #i) ∧
      (AuthenticatorSendsInitialM3( authThreadID, authID, PMK, suppThreadID,
                                    prePTK, ANonce, SNonce, prectr
       ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ authThreadID authID PMK suppThreadID PTK ANonce SNonce ctr #i.
  (AuthenticatorInstalled( authThreadID, authID, PMK, suppThreadID, PTK,
                           ANonce, SNonce, ctr
   ) @ #i)
 ∧
  ∀ prePTK prectr #j.
   (AuthenticatorSendsInitialM3( authThreadID, authID, PMK, suppThreadID,
                                 prePTK, ANonce, SNonce, prectr
    ) @ #j)
  ⇒
   ¬(#j < #i)"
*/
by sorry

lemma authenticator_installed_must_be_preceded_by_associate [reuse,
                                                             use_induction, heuristic=S]:
  all-traces
  "∀ authThreadID authID PMK suppThreadID PTK ANonce SNonce ctr #i.
    (AuthenticatorInstalled( authThreadID, authID, PMK, suppThreadID, PTK,
                             ANonce, SNonce, ctr
     ) @ #i) ⇒
    (∃ suppID #j.
      (#j < #i) ∧
      (Associate( authID, authThreadID, suppID, suppThreadID, PMK ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ authThreadID authID PMK suppThreadID PTK ANonce SNonce ctr #i.
  (AuthenticatorInstalled( authThreadID, authID, PMK, suppThreadID, PTK,
                           ANonce, SNonce, ctr
   ) @ #i)
 ∧
  ∀ suppID #j.
   (Associate( authID, authThreadID, suppID, suppThreadID, PMK ) @ #j)
  ⇒
   ¬(#j < #i)"
*/
by sorry

lemma only_one_supplicant_can_be_installed_for_a_pmk [reuse,
                                                      heuristic=C]:
  all-traces
  "∀ suppThreadID1 suppThreadID2 suppID1 suppID2 GTK1 GTK2 PMK PTK1 PTK2
     ptkDfNonce1 ptkDfNonce2 ptkMfNonce1 ptkMfNonce2 ANonce1 ANonce2 SNonce1
     SNonce2 #i #j.
    ((SupplicantInstalledPTK( suppThreadID1, suppID1, PMK, PTK1, ptkDfNonce1,
                              ptkMfNonce1, GTK1, ANonce1, SNonce1
      ) @ #i) ∧
     (SupplicantInstalledPTK( suppThreadID2, suppID2, PMK, PTK2, ptkDfNonce2,
                              ptkMfNonce2, GTK2, ANonce2, SNonce2
      ) @ #j)) ⇒
    (suppThreadID1 = suppThreadID2)"
/*
guarded formula characterizing all counter-examples:
"∃ suppThreadID1 suppThreadID2 suppID1 suppID2 GTK1 GTK2 PMK PTK1 PTK2
   ptkDfNonce1 ptkDfNonce2 ptkMfNonce1 ptkMfNonce2 ANonce1 ANonce2 SNonce1
   SNonce2 #i #j.
  (SupplicantInstalledPTK( suppThreadID1, suppID1, PMK, PTK1, ptkDfNonce1,
                           ptkMfNonce1, GTK1, ANonce1, SNonce1
   ) @ #i) ∧
  (SupplicantInstalledPTK( suppThreadID2, suppID2, PMK, PTK2, ptkDfNonce2,
                           ptkMfNonce2, GTK2, ANonce2, SNonce2
   ) @ #j)
 ∧
  ¬(suppThreadID1 = suppThreadID2)"
*/
by sorry

lemma supplicant_wnm_sleep_thread_has_to_start [use_induction, reuse,
                                                heuristic=S]:
  all-traces
  "∀ suppThreadID suppID PMK #i.
    (SupplicantStartsSleep( suppThreadID, suppID, PMK ) @ #i) ⇒
    (∃ #j.
      (#j < #i) ∧
      (SupplicantStartsWNMSleepModeThread( suppThreadID, suppID, PMK ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ suppThreadID suppID PMK #i.
  (SupplicantStartsSleep( suppThreadID, suppID, PMK ) @ #i)
 ∧
  ∀ #j.
   (SupplicantStartsWNMSleepModeThread( suppThreadID, suppID, PMK ) @ #j)
  ⇒
   ¬(#j < #i)"
*/
by sorry

lemma authenticator_wnm_sleep_thread_has_to_start [use_induction, reuse,
                                                   heuristic=S]:
  all-traces
  "∀ authThreadID authID PMK #i.
    (AuthenticatorAcceptsWNMRequest( authThreadID, authID, PMK ) @ #i) ⇒
    (∃ #j.
      (#j < #i) ∧
      (AuthenticatorStartsWNMSleepModeThread( authThreadID, authID, PMK
       ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ authThreadID authID PMK #i.
  (AuthenticatorAcceptsWNMRequest( authThreadID, authID, PMK ) @ #i)
 ∧
  ∀ #j.
   (AuthenticatorStartsWNMSleepModeThread( authThreadID, authID, PMK ) @ #j)
  ⇒
   ¬(#j < #i)"
*/
by sorry

lemma pmks_are_secret_unless_revealed [reuse]:
  all-traces
  "∀ authID authThreadID suppID suppThreadID PMK #i #j.
    ((Associate( authID, authThreadID, suppID, suppThreadID, PMK ) @ #i) ∧
     (K( PMK ) @ #j)) ⇒
    (∃ #k. (#k < #j) ∧ (RevealPMK( PMK ) @ #k))"
/*
guarded formula characterizing all counter-examples:
"∃ authID authThreadID suppID suppThreadID PMK #i #j.
  (Associate( authID, authThreadID, suppID, suppThreadID, PMK ) @ #i) ∧
  (K( PMK ) @ #j)
 ∧
  ∀ #k. (RevealPMK( PMK ) @ #k) ⇒ ¬(#k < #j)"
*/
by sorry

lemma pmks_are_ku_secret_unless_revealed [reuse]:
  all-traces
  "∀ authID authThreadID suppID suppThreadID PMK #i #j.
    ((Associate( authID, authThreadID, suppID, suppThreadID, PMK ) @ #i) ∧
     (!KU( PMK ) @ #j)) ⇒
    (∃ #k. (#k < #j) ∧ (RevealPMK( PMK ) @ #k))"
/*
guarded formula characterizing all counter-examples:
"∃ authID authThreadID suppID suppThreadID PMK #i #j.
  (Associate( authID, authThreadID, suppID, suppThreadID, PMK ) @ #i) ∧
  (!KU( PMK ) @ #j)
 ∧
  ∀ #k. (RevealPMK( PMK ) @ #k) ⇒ ¬(#k < #j)"
*/
by sorry

lemma supplicant_ptk_installation_is_unique_for_ptk [reuse, heuristic=S]:
  all-traces
  "∀ suppThreadID1 suppThreadID2 suppID1 suppID2 PMK PTK GTK1 GTK2
     ptkDfNonce1 ptkMfNonce1 ptkDfNonce2 ptkMfNonce2 ANonce1 ANonce2 SNonce1
     SNonce2 #i #j.
    ((SupplicantInstalledPTK( suppThreadID1, suppID1, PMK, PTK, ptkDfNonce1,
                              ptkMfNonce1, GTK1, ANonce1, SNonce1
      ) @ #i) ∧
     (SupplicantInstalledPTK( suppThreadID2, suppID2, PMK, PTK, ptkDfNonce2,
                              ptkMfNonce2, GTK2, ANonce2, SNonce2
      ) @ #j)) ⇒
    (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ suppThreadID1 suppThreadID2 suppID1 suppID2 PMK PTK GTK1 GTK2
   ptkDfNonce1 ptkMfNonce1 ptkDfNonce2 ptkMfNonce2 ANonce1 ANonce2 SNonce1
   SNonce2 #i #j.
  (SupplicantInstalledPTK( suppThreadID1, suppID1, PMK, PTK, ptkDfNonce1,
                           ptkMfNonce1, GTK1, ANonce1, SNonce1
   ) @ #i) ∧
  (SupplicantInstalledPTK( suppThreadID2, suppID2, PMK, PTK, ptkDfNonce2,
                           ptkMfNonce2, GTK2, ANonce2, SNonce2
   ) @ #j)
 ∧
  ¬(#i = #j)"
*/
by sorry

lemma authenticator_ptk_installation_is_unique_for_ptk [reuse,
                                                        heuristic=S]:
  all-traces
  "∀ authThreadID1 authThreadID2 authID1 authID2 PMK suppThreadID1
     suppThreadID2 PTK ANonce1 ANonce2 SNonce1 SNonce2 ctr1 ctr2 #i #j.
    ((AuthenticatorInstalled( authThreadID1, authID1, PMK, suppThreadID1,
                              PTK, ANonce1, SNonce1, ctr1
      ) @ #i) ∧
     (AuthenticatorInstalled( authThreadID2, authID2, PMK, suppThreadID2, PTK,
                              ANonce2, SNonce2, ctr2
      ) @ #j)) ⇒
    (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ authThreadID1 authThreadID2 authID1 authID2 PMK suppThreadID1
   suppThreadID2 PTK ANonce1 ANonce2 SNonce1 SNonce2 ctr1 ctr2 #i #j.
  (AuthenticatorInstalled( authThreadID1, authID1, PMK, suppThreadID1, PTK,
                           ANonce1, SNonce1, ctr1
   ) @ #i) ∧
  (AuthenticatorInstalled( authThreadID2, authID2, PMK, suppThreadID2, PTK,
                           ANonce2, SNonce2, ctr2
   ) @ #j)
 ∧
  ¬(#i = #j)"
*/
by sorry

lemma ptk_nonce_must_use_sender_id [reuse, heuristic=C]:
  all-traces
  "∀ keyID senderThreadID senderID PTK ctr installerID frameType #i.
    (EncryptedWithPTK( keyID, senderThreadID, senderID, PTK,
                       <ctr, installerID, frameType>
     ) @ #i) ⇒
    (senderID = installerID)"
/*
guarded formula characterizing all counter-examples:
"∃ keyID senderThreadID senderID PTK ctr installerID frameType #i.
  (EncryptedWithPTK( keyID, senderThreadID, senderID, PTK,
                     <ctr, installerID, frameType>
   ) @ #i)
 ∧
  ¬(senderID = installerID)"
*/
by sorry

lemma different_ptk_id_must_have_different_ptk_nonce_pairs [reuse,
                                                            heuristic=S]:
  all-traces
  "∀ keyID1 keyID2 senderID1 senderID2 senderThreadID1 senderThreadID2 PTK
     nonce #i #j.
    ((EncryptedWithPTK( keyID1, senderThreadID1, senderID1, PTK, nonce
      )[+] @ #i) ∧
     (EncryptedWithPTK( keyID2, senderThreadID2, senderID2, PTK, nonce
      )[+] @ #j)) ⇒
    (keyID1 = keyID2)"
/*
guarded formula characterizing all counter-examples:
"∃ keyID1 keyID2 senderID1 senderID2 senderThreadID1 senderThreadID2 PTK
   nonce #i #j.
  (EncryptedWithPTK( keyID1, senderThreadID1, senderID1, PTK, nonce
   )[+] @ #i) ∧
  (EncryptedWithPTK( keyID2, senderThreadID2, senderID2, PTK, nonce
   )[+] @ #j)
 ∧
  ¬(keyID1 = keyID2)"
*/
by sorry

lemma authenticator_and_supplicant_have_different_ptk_nonce_pairs [reuse,
                                                                   heuristic=S]:
  all-traces
  "∀ keyID1 keyID2 authID suppID authThreadID suppThreadID PTK nonce #i #j.
    ((SuppEncryptedWithPTK( keyID1, suppThreadID, suppID, PTK, nonce
      )[+] @ #i) ∧
     (AuthEncryptedWithPTK( keyID2, authThreadID, authID, PTK, nonce
      )[+] @ #j)) ⇒
    (⊥)"
/*
guarded formula characterizing all counter-examples:
"∃ keyID1 keyID2 authID suppID authThreadID suppThreadID PTK nonce #i #j.
  (SuppEncryptedWithPTK( keyID1, suppThreadID, suppID, PTK, nonce
   )[+] @ #i) ∧
  (AuthEncryptedWithPTK( keyID2, authThreadID, authID, PTK, nonce
   )[+] @ #j)"
*/
by sorry

lemma authenticator_ptk_nonce_pair_is_unique [reuse, use_induction,
                                              heuristic=S]:
  all-traces
  "∀ keyID1 keyID2 authID1 authID2 authThreadID1 authThreadID2 PTK nonce #i
     #j.
    (((#i < #j) ∧
      (AuthEncryptedWithPTK( keyID1, authThreadID1, authID1, PTK, nonce
       )[+] @ #i)) ∧
     (AuthEncryptedWithPTK( keyID2, authThreadID2, authID2, PTK, nonce
      )[+] @ #j)) ⇒
    (⊥)"
/*
guarded formula characterizing all counter-examples:
"∃ keyID1 keyID2 authID1 authID2 authThreadID1 authThreadID2 PTK nonce #i
   #j.
  (AuthEncryptedWithPTK( keyID1, authThreadID1, authID1, PTK, nonce
   )[+] @ #i) ∧
  (AuthEncryptedWithPTK( keyID2, authThreadID2, authID2, PTK, nonce
   )[+] @ #j)
 ∧
  #i < #j"
*/
by sorry

lemma supplicant_ptk_nonce_pair_is_unique [reuse, use_induction,
                                           heuristic=S, hide_lemma=supplicant_used_ptks_must_be_installed]:
  all-traces
  "∀ keyID1 keyID2 suppID1 suppID2 suppThreadID1 suppThreadID2 PTK nonce #i
     #j.
    (((#i < #j) ∧
      (SuppEncryptedWithPTK( keyID1, suppThreadID1, suppID1, PTK, nonce
       )[+] @ #i)) ∧
     (SuppEncryptedWithPTK( keyID2, suppThreadID2, suppID2, PTK, nonce
      )[+] @ #j)) ⇒
    (⊥)"
/*
guarded formula characterizing all counter-examples:
"∃ keyID1 keyID2 suppID1 suppID2 suppThreadID1 suppThreadID2 PTK nonce #i
   #j.
  (SuppEncryptedWithPTK( keyID1, suppThreadID1, suppID1, PTK, nonce
   )[+] @ #i) ∧
  (SuppEncryptedWithPTK( keyID2, suppThreadID2, suppID2, PTK, nonce
   )[+] @ #j)
 ∧
  #i < #j"
*/
by sorry

lemma ptk_nonce_pair_is_unique [reuse, heuristic=S]:
  all-traces
  "∀ keyID1 keyID2 senderID1 senderID2 senderThreadID1 senderThreadID2 PTK
     nonce #i #j.
    ((EncryptedWithPTK( keyID1, senderThreadID1, senderID1, PTK, nonce
      )[+] @ #i) ∧
     (EncryptedWithPTK( keyID2, senderThreadID2, senderID2, PTK, nonce
      )[+] @ #j)) ⇒
    (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ keyID1 keyID2 senderID1 senderID2 senderThreadID1 senderThreadID2 PTK
   nonce #i #j.
  (EncryptedWithPTK( keyID1, senderThreadID1, senderID1, PTK, nonce
   )[+] @ #i) ∧
  (EncryptedWithPTK( keyID2, senderThreadID2, senderID2, PTK, nonce
   )[+] @ #j)
 ∧
  ¬(#i = #j)"
*/
by sorry

lemma supplicant_ptk_is_secret [heuristic=S, reuse]:
  all-traces
  "∀ suppThreadID suppID PMK PTK ptkDfNonce ptkMfNonce GTK ANonce SNonce
     #i.
    ((SupplicantInstalledPTK( suppThreadID, suppID, PMK, PTK, ptkDfNonce,
                              ptkMfNonce, GTK, ANonce, SNonce
      ) @ #i) ∧
     (¬(∃ #j. RevealPMK( PMK ) @ #j))) ⇒
    (¬(∃ #k. K( PTK )[+] @ #k))"
/*
guarded formula characterizing all counter-examples:
"∃ suppThreadID suppID PMK PTK ptkDfNonce ptkMfNonce GTK ANonce SNonce
   #i.
  (SupplicantInstalledPTK( suppThreadID, suppID, PMK, PTK, ptkDfNonce,
                           ptkMfNonce, GTK, ANonce, SNonce
   ) @ #i)
 ∧
  (∀ #j. (RevealPMK( PMK ) @ #j) ⇒ ⊥) ∧ (∃ #k. (K( PTK )[+] @ #k))"
*/
by sorry

lemma supplicant_ptk_is_ku_secret [heuristic=S, reuse]:
  all-traces
  "∀ suppThreadID suppID PMK ANonce SNonce ptkDfNonce ptkMfNonce PTK GTK
     #i.
    ((SupplicantInstalledPTK( suppThreadID, suppID, PMK, PTK, ptkDfNonce,
                              ptkMfNonce, GTK, ANonce, SNonce
      ) @ #i) ∧
     (¬(∃ #j. RevealPMK( PMK ) @ #j))) ⇒
    (¬(∃ #k. !KU( PTK ) @ #k))"
/*
guarded formula characterizing all counter-examples:
"∃ suppThreadID suppID PMK ANonce SNonce ptkDfNonce ptkMfNonce PTK GTK
   #i.
  (SupplicantInstalledPTK( suppThreadID, suppID, PMK, PTK, ptkDfNonce,
                           ptkMfNonce, GTK, ANonce, SNonce
   ) @ #i)
 ∧
  (∀ #j. (RevealPMK( PMK ) @ #j) ⇒ ⊥) ∧ (∃ #k. (!KU( PTK ) @ #k))"
*/
by sorry

lemma supplicant_preliminary_ptk_is_secret [heuristic=S, reuse]:
  all-traces
  "∀ suppThreadID suppID PMK authThreadID PTK GTK ANonce SNonce ctr #i.
    ((SupplicantReceivesM3( suppThreadID, suppID, PMK, authThreadID, PTK,
                            GTK, ANonce, SNonce, ctr
      ) @ #i) ∧
     (¬(∃ #j. RevealPMK( PMK ) @ #j))) ⇒
    (¬(∃ #k. K( KDF(<PMK, ANonce, SNonce>) )[+] @ #k))"
/*
guarded formula characterizing all counter-examples:
"∃ suppThreadID suppID PMK authThreadID PTK GTK ANonce SNonce ctr #i.
  (SupplicantReceivesM3( suppThreadID, suppID, PMK, authThreadID, PTK, GTK,
                         ANonce, SNonce, ctr
   ) @ #i)
 ∧
  (∀ #j. (RevealPMK( PMK ) @ #j) ⇒ ⊥) ∧
  (∃ #k. (K( KDF(<PMK, ANonce, SNonce>) )[+] @ #k))"
*/
by sorry

lemma supplicant_preliminary_ptk_is_ku_secret [heuristic=S, reuse]:
  all-traces
  "∀ suppThreadID suppID PMK authThreadID PTK GTK ANonce SNonce ctr #i.
    ((SupplicantReceivesM3( suppThreadID, suppID, PMK, authThreadID, PTK,
                            GTK, ANonce, SNonce, ctr
      ) @ #i) ∧
     (¬(∃ #j. RevealPMK( PMK ) @ #j))) ⇒
    (¬(∃ #k. !KU( KDF(<PMK, ANonce, SNonce>) ) @ #k))"
/*
guarded formula characterizing all counter-examples:
"∃ suppThreadID suppID PMK authThreadID PTK GTK ANonce SNonce ctr #i.
  (SupplicantReceivesM3( suppThreadID, suppID, PMK, authThreadID, PTK, GTK,
                         ANonce, SNonce, ctr
   ) @ #i)
 ∧
  (∀ #j. (RevealPMK( PMK ) @ #j) ⇒ ⊥) ∧
  (∃ #k. (!KU( KDF(<PMK, ANonce, SNonce>) ) @ #k))"
*/
by sorry

lemma authenticator_ptk_is_secret [heuristic=S, reuse]:
  all-traces
  "∀ authThreadID authID PMK suppThreadID PTK ANonce SNonce ctr #i.
    ((AuthenticatorInstalled( authThreadID, authID, PMK, suppThreadID, PTK,
                              ANonce, SNonce, ctr
      ) @ #i) ∧
     (¬(∃ #j. RevealPMK( PMK ) @ #j))) ⇒
    (¬(∃ #k. K( PTK )[+] @ #k))"
/*
guarded formula characterizing all counter-examples:
"∃ authThreadID authID PMK suppThreadID PTK ANonce SNonce ctr #i.
  (AuthenticatorInstalled( authThreadID, authID, PMK, suppThreadID, PTK,
                           ANonce, SNonce, ctr
   ) @ #i)
 ∧
  (∀ #j. (RevealPMK( PMK ) @ #j) ⇒ ⊥) ∧ (∃ #k. (K( PTK )[+] @ #k))"
*/
by sorry

lemma authenticator_ptk_is_ku_secret [heuristic=S, reuse]:
  all-traces
  "∀ authThreadID authID PMK suppThreadID ANonce SNonce PTK ctr #i.
    ((AuthenticatorInstalled( authThreadID, authID, PMK, suppThreadID, PTK,
                              ANonce, SNonce, ctr
      ) @ #i) ∧
     (¬(∃ #j. RevealPMK( PMK ) @ #j))) ⇒
    (¬(∃ #k. !KU( PTK ) @ #k))"
/*
guarded formula characterizing all counter-examples:
"∃ authThreadID authID PMK suppThreadID ANonce SNonce PTK ctr #i.
  (AuthenticatorInstalled( authThreadID, authID, PMK, suppThreadID, PTK,
                           ANonce, SNonce, ctr
   ) @ #i)
 ∧
  (∀ #j. (RevealPMK( PMK ) @ #j) ⇒ ⊥) ∧ (∃ #k. (!KU( PTK ) @ #k))"
*/
by sorry

lemma authenticator_preliminary_ptk_is_secret [reuse, heuristic=S]:
  all-traces
  "∀ authThreadID authID PMK suppThreadID oldPTK ANonce SNonce ctr #i.
    ((AuthenticatorSendsInitialM3( authThreadID, authID, PMK, suppThreadID,
                                   oldPTK, ANonce, SNonce, ctr
      ) @ #i) ∧
     (¬(∃ #j. RevealPMK( PMK ) @ #j))) ⇒
    (¬(∃ #k. K( KDF(<PMK, ANonce, SNonce>) )[+] @ #k))"
/*
guarded formula characterizing all counter-examples:
"∃ authThreadID authID PMK suppThreadID oldPTK ANonce SNonce ctr #i.
  (AuthenticatorSendsInitialM3( authThreadID, authID, PMK, suppThreadID,
                                oldPTK, ANonce, SNonce, ctr
   ) @ #i)
 ∧
  (∀ #j. (RevealPMK( PMK ) @ #j) ⇒ ⊥) ∧
  (∃ #k. (K( KDF(<PMK, ANonce, SNonce>) )[+] @ #k))"
*/
by sorry

lemma authenticator_preliminary_ptk_is_ku_secret [reuse, heuristic=S]:
  all-traces
  "∀ authThreadID authID PMK suppThreadID oldPTK ANonce SNonce ctr #i.
    ((AuthenticatorSendsInitialM3( authThreadID, authID, PMK, suppThreadID,
                                   oldPTK, ANonce, SNonce, ctr
      ) @ #i) ∧
     (¬(∃ #j. RevealPMK( PMK ) @ #j))) ⇒
    (¬(∃ #k. !KU( KDF(<PMK, ANonce, SNonce>) ) @ #k))"
/*
guarded formula characterizing all counter-examples:
"∃ authThreadID authID PMK suppThreadID oldPTK ANonce SNonce ctr #i.
  (AuthenticatorSendsInitialM3( authThreadID, authID, PMK, suppThreadID,
                                oldPTK, ANonce, SNonce, ctr
   ) @ #i)
 ∧
  (∀ #j. (RevealPMK( PMK ) @ #j) ⇒ ⊥) ∧
  (∃ #k. (!KU( KDF(<PMK, ANonce, SNonce>) ) @ #k))"
*/
by sorry

lemma authenticator_authentication [heuristic=S]:
  all-traces
  "∀ authThreadID suppThreadID PMK ANonce SNonce PTK #i.
    ((AuthenticatorCommit( authThreadID, suppThreadID, PMK, ANonce, SNonce,
                           PTK
      ) @ #i) ∧
     (¬(∃ #r. RevealPMK( PMK ) @ #r))) ⇒
    (∃ #j.
      (#j < #i) ∧
      (SupplicantRunning( suppThreadID, authThreadID, PMK, ANonce, SNonce, PTK
       ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ authThreadID suppThreadID PMK ANonce SNonce PTK #i.
  (AuthenticatorCommit( authThreadID, suppThreadID, PMK, ANonce, SNonce,
                        PTK
   ) @ #i)
 ∧
  (∀ #r. (RevealPMK( PMK ) @ #r) ⇒ ⊥) ∧
  (∀ #j.
    (SupplicantRunning( suppThreadID, authThreadID, PMK, ANonce, SNonce, PTK
     ) @ #j)
   ⇒
    ¬(#j < #i))"
*/
by sorry

lemma supplicant_authentication [heuristic=S]:
  all-traces
  "∀ suppThreadID authThreadID PMK ANonce SNonce PTK #i.
    ((SupplicantCommit( suppThreadID, authThreadID, PMK, ANonce, SNonce, PTK
      ) @ #i) ∧
     (¬(∃ #r. RevealPMK( PMK ) @ #r))) ⇒
    (∃ #j.
      (#j < #i) ∧
      (AuthenticatorRunning( authThreadID, suppThreadID, PMK, ANonce, SNonce,
                             PTK
       ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ suppThreadID authThreadID PMK ANonce SNonce PTK #i.
  (SupplicantCommit( suppThreadID, authThreadID, PMK, ANonce, SNonce, PTK
   ) @ #i)
 ∧
  (∀ #r. (RevealPMK( PMK ) @ #r) ⇒ ⊥) ∧
  (∀ #j.
    (AuthenticatorRunning( authThreadID, suppThreadID, PMK, ANonce, SNonce,
                           PTK
     ) @ #j)
   ⇒
    ¬(#j < #i))"
*/
by sorry

lemma helper_authenticator_gtk_installation_is_unique_for_gtk [reuse,
                                                               heuristic=C]:
  all-traces
  "∀ authID groupKey n index1 index2 #i #j.
    (((AuthenticatorInstalledGTK( authID, <groupKey, <N(n), authID>, index1>
       )[+] @ #i) ∧
      (AuthenticatorInstalledGTK( authID, <groupKey, <N(n), authID>, index2>
       )[+] @ #j)) ∧
     (#i < #j)) ⇒
    (⊥)"
/*
guarded formula characterizing all counter-examples:
"∃ authID groupKey n index1 index2 #i #j.
  (AuthenticatorInstalledGTK( authID, <groupKey, <N(n), authID>, index1>
   )[+] @ #i) ∧
  (AuthenticatorInstalledGTK( authID, <groupKey, <N(n), authID>, index2>
   )[+] @ #j)
 ∧
  #i < #j"
*/
by sorry

lemma authenticator_gtk_installation_is_unique_for_gtk [reuse,
                                                        heuristic=S]:
  all-traces
  "∀ authID groupKey n index1 index2 #i #j.
    ((AuthenticatorInstalledGTK( authID, <groupKey, <N(n), authID>, index1>
      ) @ #i) ∧
     (AuthenticatorInstalledGTK( authID, <groupKey, <N(n), authID>, index2>
      ) @ #j)) ⇒
    (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ authID groupKey n index1 index2 #i #j.
  (AuthenticatorInstalledGTK( authID, <groupKey, <N(n), authID>, index1>
   ) @ #i) ∧
  (AuthenticatorInstalledGTK( authID, <groupKey, <N(n), authID>, index2>
   ) @ #j)
 ∧
  ¬(#i = #j)"
*/
by sorry

lemma gtk_encryption_nonces_increase_strictly_over_time [reuse,
                                                         use_induction, heuristic=S]:
  all-traces
  "∀ authID GTK m n index1 index2 shareGTKData1 shareGTKData2 #i #j.
    (((EncryptedWithGTK( authID, <GTK, <N(n), authID>, index1>, shareGTKData1
       )[+] @ #i) ∧
      (EncryptedWithGTK( authID, <GTK, <N(m), authID>, index2>, shareGTKData2
       )[+] @ #j)) ∧
     (#i < #j)) ⇒
    (∃ z. m = (n+z))"
/*
guarded formula characterizing all counter-examples:
"∃ authID GTK m n index1 index2 shareGTKData1 shareGTKData2 #i #j.
  (EncryptedWithGTK( authID, <GTK, <N(n), authID>, index1>, shareGTKData1
   )[+] @ #i) ∧
  (EncryptedWithGTK( authID, <GTK, <N(m), authID>, index2>, shareGTKData2
   )[+] @ #j)
 ∧
  (#i < #j) ∧ (∀ z. (m = (n+z)) ⇒ ⊥)"
*/
by sorry

lemma gtk_nonce_pair_is_unique [reuse, use_induction, heuristic=S]:
  all-traces
  "∀ authID1 authID2 GTK nonce index1 index2 shareGTKData1 shareGTKData2 #i
     #j.
    ((EncryptedWithGTK( authID1, <GTK, nonce, index1>, shareGTKData1
      )[+] @ #i) ∧
     (EncryptedWithGTK( authID2, <GTK, nonce, index2>, shareGTKData2
      )[+] @ #j)) ⇒
    (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ authID1 authID2 GTK nonce index1 index2 shareGTKData1 shareGTKData2 #i
   #j.
  (EncryptedWithGTK( authID1, <GTK, nonce, index1>, shareGTKData1
   )[+] @ #i) ∧
  (EncryptedWithGTK( authID2, <GTK, nonce, index2>, shareGTKData2
   )[+] @ #j)
 ∧
  ¬(#i = #j)"
*/
by sorry

lemma no_nonce_reuse_for_installed_gtk [reuse, heuristic=s]:
  all-traces
  "∀ authID groupKey initialNonce index #i.
    ((AuthenticatorInstalledGTK( authID, <groupKey, initialNonce, index>
      ) @ #i) ∧
     (¬(∃ PMK #j. RevealPMK( PMK ) @ #j))) ⇒
    (¬(∃ nonce #j. NonceReuse( groupKey, nonce ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ authID groupKey initialNonce index #i.
  (AuthenticatorInstalledGTK( authID, <groupKey, initialNonce, index>
   ) @ #i)
 ∧
  (∀ PMK #j. (RevealPMK( PMK ) @ #j) ⇒ ⊥) ∧
  (∃ nonce #j. (NonceReuse( groupKey, nonce ) @ #j))"
*/
by sorry

lemma authenticator_gtk_is_secret [heuristic=S, reuse]:
  all-traces
  "∀ authID GTK nonce index #i.
    ((AuthenticatorInstalledGTK( authID, <GTK, nonce, index> ) @ #i) ∧
     (¬(∃ PMK #j. RevealPMK( PMK ) @ #j))) ⇒
    (¬(∃ #k. K( GTK )[+] @ #k))"
/*
guarded formula characterizing all counter-examples:
"∃ authID GTK nonce index #i.
  (AuthenticatorInstalledGTK( authID, <GTK, nonce, index> ) @ #i)
 ∧
  (∀ PMK #j. (RevealPMK( PMK ) @ #j) ⇒ ⊥) ∧ (∃ #k. (K( GTK )[+] @ #k))"
*/
by sorry

lemma authenticator_gtk_is_ku_secret [heuristic=S, reuse]:
  all-traces
  "∀ authID GTK nonce index #i.
    ((AuthenticatorInstalledGTK( authID, <GTK, nonce, index> ) @ #i) ∧
     (¬(∃ PMK #j. RevealPMK( PMK ) @ #j))) ⇒
    (¬(∃ #k. !KU( GTK ) @ #k))"
/*
guarded formula characterizing all counter-examples:
"∃ authID GTK nonce index #i.
  (AuthenticatorInstalledGTK( authID, <GTK, nonce, index> ) @ #i)
 ∧
  (∀ PMK #j. (RevealPMK( PMK ) @ #j) ⇒ ⊥) ∧ (∃ #k. (!KU( GTK ) @ #k))"
*/
by sorry

lemma authenticator_sets_share_gtk_is_secret [heuristic=S, reuse,
                                              hide_lemma=authenticator_use_gtk_must_be_preceded_by_install_gtk,
                                              hide_lemma=authenticator_use_gtk_must_be_preceded_by_set_share_gtk,
                                              hide_lemma=authenticator_gtk_rekey_must_be_preceded_by_create,
                                              hide_lemma=authenticator_encryption_gtks_must_be_installed,
                                              hide_lemma=authenticator_gtk_is_secret,
                                              hide_lemma=authenticator_gtk_is_ku_secret,
                                              hide_lemma=authenticator_preliminary_ptk_is_secret,
                                              hide_lemma=authenticator_ptk_is_secret]:
  all-traces
  "∀ authID GTK nonce index #i.
    (((AuthenticatorSetsShareGTK( authID, <GTK, nonce, index> ) @ #i) ∧
      (¬(∃ #l.
          AuthenticatorInstalledGTK( authID, <GTK, nonce, index> ) @ #l))) ∧
     (¬(∃ PMK1 #j. RevealPMK( PMK1 ) @ #j))) ⇒
    (¬(∃ #k. K( GTK )[+] @ #k))"
/*
guarded formula characterizing all counter-examples:
"∃ authID GTK nonce index #i.
  (AuthenticatorSetsShareGTK( authID, <GTK, nonce, index> ) @ #i)
 ∧
  (∀ #l.
    (AuthenticatorInstalledGTK( authID, <GTK, nonce, index> ) @ #l) ⇒ ⊥) ∧
  (∀ PMK1 #j. (RevealPMK( PMK1 ) @ #j) ⇒ ⊥) ∧
  (∃ #k. (K( GTK )[+] @ #k))"
*/
by sorry

lemma authenticator_sets_share_gtk_is_ku_secret [heuristic=S, reuse,
                                                 hide_lemma=authenticator_use_gtk_must_be_preceded_by_install_gtk,
                                                 hide_lemma=authenticator_use_gtk_must_be_preceded_by_set_share_gtk,
                                                 hide_lemma=authenticator_gtk_rekey_must_be_preceded_by_create,
                                                 hide_lemma=authenticator_encryption_gtks_must_be_installed,
                                                 hide_lemma=authenticator_gtk_is_secret,
                                                 hide_lemma=authenticator_gtk_is_ku_secret,
                                                 hide_lemma=authenticator_preliminary_ptk_is_secret,
                                                 hide_lemma=authenticator_ptk_is_secret]:
  all-traces
  "∀ authID GTK nonce index #i.
    (((AuthenticatorSetsShareGTK( authID, <GTK, nonce, index> ) @ #i) ∧
      (¬(∃ #l.
          AuthenticatorInstalledGTK( authID, <GTK, nonce, index> ) @ #l))) ∧
     (¬(∃ PMK1 #j. RevealPMK( PMK1 ) @ #j))) ⇒
    (¬(∃ #k. !KU( GTK ) @ #k))"
/*
guarded formula characterizing all counter-examples:
"∃ authID GTK nonce index #i.
  (AuthenticatorSetsShareGTK( authID, <GTK, nonce, index> ) @ #i)
 ∧
  (∀ #l.
    (AuthenticatorInstalledGTK( authID, <GTK, nonce, index> ) @ #l) ⇒ ⊥) ∧
  (∀ PMK1 #j. (RevealPMK( PMK1 ) @ #j) ⇒ ⊥) ∧
  (∃ #k. (!KU( GTK ) @ #k))"
*/
by sorry

lemma authenticator_shared_gtk_is_ku_secret [heuristic=S, reuse]:
  all-traces
  "∀ authThreadID authID PMK GTK nonce index #i.
    ((AuthenticatorSharesGTK( authThreadID, authID, PMK, <GTK, nonce, index>
      ) @ #i) ∧
     (¬(∃ PMK1 #j. RevealPMK( PMK1 ) @ #j))) ⇒
    (¬(∃ #k. !KU( GTK ) @ #k))"
/*
guarded formula characterizing all counter-examples:
"∃ authThreadID authID PMK GTK nonce index #i.
  (AuthenticatorSharesGTK( authThreadID, authID, PMK, <GTK, nonce, index>
   ) @ #i)
 ∧
  (∀ PMK1 #j. (RevealPMK( PMK1 ) @ #j) ⇒ ⊥) ∧ (∃ #k. (!KU( GTK ) @ #k))"
*/
by sorry

lemma supplicant_gtk_installation_is_unique_for_gtk_id [heuristic=S,
                                                        reuse,
                                                        hide_lemma=supplicant_preliminary_ptk_is_secret,
                                                        hide_lemma=authenticator_shared_gtk_is_ku_secret,
                                                        hide_lemma=authenticator_shared_gtk_is_secret,
                                                        hide_lemma=authenticator_sets_share_gtk_is_secret,
                                                        hide_lemma=authenticator_sets_share_gtk_is_ku_secret,
                                                        hide_lemma=authenticator_gtk_is_secret,
                                                        hide_lemma=authenticator_gtk_is_ku_secret,
                                                        hide_lemma=no_nonce_reuse_for_installed_gtk]:
  all-traces
  "∀ gtkID suppThreadID1 PMK1 GTK1 n1 index1 authID1 suppThreadID2 PMK2
     GTK2 n2 index2 authID2 #i #j.
    ((SupplicantInstalledGTK( gtkID, suppThreadID1, PMK1, GTK1,
                              <N(n1), authID1>, index1
      ) @ #i) ∧
     (SupplicantInstalledGTK( gtkID, suppThreadID2, PMK2, GTK2,
                              <N(n2), authID2>, index2
      ) @ #j)) ⇒
    (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ gtkID suppThreadID1 PMK1 GTK1 n1 index1 authID1 suppThreadID2 PMK2
   GTK2 n2 index2 authID2 #i #j.
  (SupplicantInstalledGTK( gtkID, suppThreadID1, PMK1, GTK1,
                           <N(n1), authID1>, index1
   ) @ #i) ∧
  (SupplicantInstalledGTK( gtkID, suppThreadID2, PMK2, GTK2,
                           <N(n2), authID2>, index2
   ) @ #j)
 ∧
  ¬(#i = #j)"
*/
by sorry

lemma supplicant_receiver_gtk_must_be_installed [reuse, use_induction,
                                                 heuristic=S]:
  all-traces
  "∀ keyID suppThreadID PMK GTK n authID #i.
    (ReceiveGTKEncryptedPayload( keyID, suppThreadID, PMK, GTK,
                                 <N(n), authID>
     ) @ #i) ⇒
    (∃ m index #j.
      (#j < #i) ∧
      (SupplicantInstalledGTK( keyID, suppThreadID, PMK, GTK, <N(m), authID>,
                               index
       ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ keyID suppThreadID PMK GTK n authID #i.
  (ReceiveGTKEncryptedPayload( keyID, suppThreadID, PMK, GTK,
                               <N(n), authID>
   ) @ #i)
 ∧
  ∀ m index #j.
   (SupplicantInstalledGTK( keyID, suppThreadID, PMK, GTK, <N(m), authID>,
                            index
    ) @ #j)
  ⇒
   ¬(#j < #i)"
*/
by sorry

lemma supplicant_gtk_installation_means_auth_sent_gtk [reuse,
                                                       heuristic=C,
                                                       hide_lemma=supplicant_preliminary_ptk_is_secret,
                                                       hide_lemma=authenticator_shared_gtk_is_ku_secret,
                                                       hide_lemma=authenticator_shared_gtk_is_secret,
                                                       hide_lemma=authenticator_sets_share_gtk_is_secret,
                                                       hide_lemma=authenticator_sets_share_gtk_is_ku_secret,
                                                       hide_lemma=authenticator_gtk_is_secret,
                                                       hide_lemma=authenticator_gtk_is_ku_secret,
                                                       hide_lemma=no_nonce_reuse_for_installed_gtk]:
  all-traces
  "∀ suppThreadID gtkID PMK authID GTK n index #i.
    ((SupplicantInstalledGTK( gtkID, suppThreadID, PMK, GTK, <N(n), authID>,
                              index
      ) @ #i) ∧
     (¬(∃ #k. RevealPMK( PMK ) @ #k))) ⇒
    (∃ authID.1 authThreadID #j.
      (#j < #i) ∧
      (AuthenticatorSharesGTK( authThreadID, authID.1, PMK,
                               <GTK, <N(n), authID.1>, index>
       ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ suppThreadID gtkID PMK authID GTK n index #i.
  (SupplicantInstalledGTK( gtkID, suppThreadID, PMK, GTK, <N(n), authID>,
                           index
   ) @ #i)
 ∧
  (∀ #k. (RevealPMK( PMK ) @ #k) ⇒ ⊥) ∧
  (∀ authID.1 authThreadID #j.
    (AuthenticatorSharesGTK( authThreadID, authID.1, PMK,
                             <GTK, <N(n), authID.1>, index>
     ) @ #j)
   ⇒
    ¬(#j < #i))"
*/
by sorry

lemma supplicant_gtk_is_secret [heuristic=S, reuse]:
  all-traces
  "∀ suppThreadID gtkID PMK authID GTK n index #i.
    ((SupplicantInstalledGTK( gtkID, suppThreadID, PMK, GTK, <N(n), authID>,
                              index
      ) @ #i) ∧
     (¬(∃ PMK.1 #j. RevealPMK( PMK.1 ) @ #j))) ⇒
    (¬(∃ #k. K( GTK )[+] @ #k))"
/*
guarded formula characterizing all counter-examples:
"∃ suppThreadID gtkID PMK authID GTK n index #i.
  (SupplicantInstalledGTK( gtkID, suppThreadID, PMK, GTK, <N(n), authID>,
                           index
   ) @ #i)
 ∧
  (∀ PMK.1 #j. (RevealPMK( PMK.1 ) @ #j) ⇒ ⊥) ∧ (∃ #k. (K( GTK )[+] @ #k))"
*/
by sorry

lemma supplicant_gtk_is_ku_secret [heuristic=S, reuse]:
  all-traces
  "∀ suppThreadID gtkID PMK authID GTK n index #i.
    ((SupplicantInstalledGTK( gtkID, suppThreadID, PMK, GTK, <N(n), authID>,
                              index
      ) @ #i) ∧
     (¬(∃ PMK.1 #j. RevealPMK( PMK.1 ) @ #j))) ⇒
    (¬(∃ #k. !KU( GTK ) @ #k))"
/*
guarded formula characterizing all counter-examples:
"∃ suppThreadID gtkID PMK authID GTK n index #i.
  (SupplicantInstalledGTK( gtkID, suppThreadID, PMK, GTK, <N(n), authID>,
                           index
   ) @ #i)
 ∧
  (∀ PMK.1 #j. (RevealPMK( PMK.1 ) @ #j) ⇒ ⊥) ∧ (∃ #k. (!KU( GTK ) @ #k))"
*/
by sorry

lemma supplicant_can_wake_up [heuristic=S,
                              hide_lemma=supplicant_gtk_installation_means_auth_sent_gtk,
                              hide_lemma=supplicant_receiver_gtk_must_be_installed,
                              hide_lemma=pmks_are_secret_unless_revealed,
                              hide_lemma=pmks_are_ku_secret_unless_revealed,
                              hide_lemma=authenticator_used_ptks_must_be_installed,
                              hide_lemma=supplicant_used_ptks_must_be_installed,
                              hide_lemma=authenticator_use_gtk_must_be_preceded_by_install_gtk,
                              hide_lemma=authenticator_use_gtk_must_be_preceded_by_set_share_gtk,
                              hide_lemma=authenticator_gtk_rekey_must_be_preceded_by_create,
                              hide_lemma=authenticator_encryption_gtks_must_be_installed,
                              hide_lemma=supplicant_ptk_is_secret,
                              hide_lemma=supplicant_ptk_is_ku_secret,
                              hide_lemma=supplicant_preliminary_ptk_is_secret,
                              hide_lemma=supplicant_preliminary_ptk_is_ku_secret,
                              hide_lemma=supplicant_gtk_is_secret,
                              hide_lemma=supplicant_gtk_is_ku_secret,
                              hide_lemma=authenticator_ptk_is_secret,
                              hide_lemma=authenticator_ptk_is_ku_secret,
                              hide_lemma=authenticator_preliminary_ptk_is_secret,
                              hide_lemma=authenticator_preliminary_ptk_is_ku_secret,
                              hide_lemma=no_nonce_reuse_for_installed_gtk,
                              hide_lemma=authenticator_shared_gtk_is_ku_secret,
                              hide_lemma=authenticator_shared_gtk_is_secret,
                              hide_lemma=authenticator_sets_share_gtk_is_secret,
                              hide_lemma=authenticator_sets_share_gtk_is_ku_secret,
                              hide_lemma=authenticator_use_gtk_must_be_preceded_by_set_share_gtk,
                              hide_lemma=authenticator_gtk_is_secret,
                              hide_lemma=authenticator_gtk_is_ku_secret]:
  exists-trace
  "∃ suppThreadID suppID PMK #i.
    SupplicantAwakes( suppThreadID, suppID, PMK ) @ #i"
/*
guarded formula characterizing all satisfying traces:
"∃ suppThreadID suppID PMK #i.
  (SupplicantAwakes( suppThreadID, suppID, PMK ) @ #i)"
*/
by sorry

lemma supplicant_can_request_sleep [heuristic=S,
                                    hide_lemma=supplicant_gtk_installation_means_auth_sent_gtk,
                                    hide_lemma=supplicant_receiver_gtk_must_be_installed,
                                    hide_lemma=pmks_are_secret_unless_revealed,
                                    hide_lemma=pmks_are_ku_secret_unless_revealed,
                                    hide_lemma=authenticator_used_ptks_must_be_installed,
                                    hide_lemma=supplicant_used_ptks_must_be_installed,
                                    hide_lemma=authenticator_use_gtk_must_be_preceded_by_install_gtk,
                                    hide_lemma=authenticator_use_gtk_must_be_preceded_by_set_share_gtk,
                                    hide_lemma=authenticator_gtk_rekey_must_be_preceded_by_create,
                                    hide_lemma=authenticator_encryption_gtks_must_be_installed,
                                    hide_lemma=supplicant_ptk_is_secret,
                                    hide_lemma=supplicant_ptk_is_ku_secret,
                                    hide_lemma=supplicant_preliminary_ptk_is_secret,
                                    hide_lemma=supplicant_preliminary_ptk_is_ku_secret,
                                    hide_lemma=supplicant_gtk_is_secret,
                                    hide_lemma=supplicant_gtk_is_ku_secret,
                                    hide_lemma=authenticator_ptk_is_secret,
                                    hide_lemma=authenticator_ptk_is_ku_secret,
                                    hide_lemma=authenticator_preliminary_ptk_is_secret,
                                    hide_lemma=authenticator_preliminary_ptk_is_ku_secret,
                                    hide_lemma=no_nonce_reuse_for_installed_gtk,
                                    hide_lemma=authenticator_shared_gtk_is_ku_secret,
                                    hide_lemma=authenticator_shared_gtk_is_secret,
                                    hide_lemma=authenticator_sets_share_gtk_is_secret,
                                    hide_lemma=authenticator_sets_share_gtk_is_ku_secret,
                                    hide_lemma=authenticator_use_gtk_must_be_preceded_by_set_share_gtk,
                                    hide_lemma=authenticator_gtk_is_secret,
                                    hide_lemma=authenticator_gtk_is_ku_secret]:
  exists-trace
  "∃ suppThreadID suppID PMK #i.
    SupplicantRequestsSleep( suppThreadID, suppID, PMK ) @ #i"
/*
guarded formula characterizing all satisfying traces:
"∃ suppThreadID suppID PMK #i.
  (SupplicantRequestsSleep( suppThreadID, suppID, PMK ) @ #i)"
*/
by sorry

lemma supplicant_can_start_wnm_thread [heuristic=S,
                                       hide_lemma=supplicant_gtk_installation_means_auth_sent_gtk,
                                       hide_lemma=supplicant_receiver_gtk_must_be_installed,
                                       hide_lemma=pmks_are_secret_unless_revealed,
                                       hide_lemma=pmks_are_ku_secret_unless_revealed,
                                       hide_lemma=authenticator_used_ptks_must_be_installed,
                                       hide_lemma=supplicant_used_ptks_must_be_installed,
                                       hide_lemma=authenticator_use_gtk_must_be_preceded_by_install_gtk,
                                       hide_lemma=authenticator_use_gtk_must_be_preceded_by_set_share_gtk,
                                       hide_lemma=authenticator_gtk_rekey_must_be_preceded_by_create,
                                       hide_lemma=authenticator_encryption_gtks_must_be_installed,
                                       hide_lemma=supplicant_ptk_is_secret,
                                       hide_lemma=supplicant_ptk_is_ku_secret,
                                       hide_lemma=supplicant_preliminary_ptk_is_secret,
                                       hide_lemma=supplicant_preliminary_ptk_is_ku_secret,
                                       hide_lemma=supplicant_gtk_is_secret,
                                       hide_lemma=supplicant_gtk_is_ku_secret,
                                       hide_lemma=authenticator_ptk_is_secret,
                                       hide_lemma=authenticator_ptk_is_ku_secret,
                                       hide_lemma=authenticator_preliminary_ptk_is_secret,
                                       hide_lemma=authenticator_preliminary_ptk_is_ku_secret,
                                       hide_lemma=no_nonce_reuse_for_installed_gtk,
                                       hide_lemma=authenticator_shared_gtk_is_ku_secret,
                                       hide_lemma=authenticator_shared_gtk_is_secret,
                                       hide_lemma=authenticator_sets_share_gtk_is_secret,
                                       hide_lemma=authenticator_sets_share_gtk_is_ku_secret,
                                       hide_lemma=authenticator_use_gtk_must_be_preceded_by_set_share_gtk,
                                       hide_lemma=authenticator_gtk_is_secret,
                                       hide_lemma=authenticator_gtk_is_ku_secret]:
  exists-trace
  "∃ suppThreadID suppID PMK #i.
    SupplicantStartsWNMSleepModeThread( suppThreadID, suppID, PMK ) @ #i"
/*
guarded formula characterizing all satisfying traces:
"∃ suppThreadID suppID PMK #i.
  (SupplicantStartsWNMSleepModeThread( suppThreadID, suppID, PMK ) @ #i)"
*/
by sorry

lemma supplicant_can_rcv_m1 [heuristic=S,
                             hide_lemma=supplicant_gtk_installation_means_auth_sent_gtk,
                             hide_lemma=supplicant_receiver_gtk_must_be_installed,
                             hide_lemma=pmks_are_secret_unless_revealed,
                             hide_lemma=pmks_are_ku_secret_unless_revealed,
                             hide_lemma=authenticator_used_ptks_must_be_installed,
                             hide_lemma=supplicant_used_ptks_must_be_installed,
                             hide_lemma=authenticator_use_gtk_must_be_preceded_by_install_gtk,
                             hide_lemma=authenticator_use_gtk_must_be_preceded_by_set_share_gtk,
                             hide_lemma=authenticator_gtk_rekey_must_be_preceded_by_create,
                             hide_lemma=authenticator_encryption_gtks_must_be_installed,
                             hide_lemma=supplicant_ptk_is_secret,
                             hide_lemma=supplicant_ptk_is_ku_secret,
                             hide_lemma=supplicant_preliminary_ptk_is_secret,
                             hide_lemma=supplicant_preliminary_ptk_is_ku_secret,
                             hide_lemma=supplicant_gtk_is_secret,
                             hide_lemma=supplicant_gtk_is_ku_secret,
                             hide_lemma=authenticator_ptk_is_secret,
                             hide_lemma=authenticator_ptk_is_ku_secret,
                             hide_lemma=authenticator_preliminary_ptk_is_secret,
                             hide_lemma=authenticator_preliminary_ptk_is_ku_secret,
                             hide_lemma=no_nonce_reuse_for_installed_gtk,
                             hide_lemma=authenticator_shared_gtk_is_ku_secret,
                             hide_lemma=authenticator_shared_gtk_is_secret,
                             hide_lemma=authenticator_sets_share_gtk_is_secret,
                             hide_lemma=authenticator_sets_share_gtk_is_ku_secret,
                             hide_lemma=authenticator_use_gtk_must_be_preceded_by_set_share_gtk,
                             hide_lemma=authenticator_gtk_is_secret,
                             hide_lemma=authenticator_gtk_is_ku_secret]:
  exists-trace
  "∃ suppThreadID suppID PMK authThreadID PTK GTK ANonce SNonce ctr #i.
    SupplicantReceivesM1( suppThreadID, suppID, PMK, authThreadID, PTK, GTK,
                          ANonce, SNonce, ctr
    ) @ #i"
/*
guarded formula characterizing all satisfying traces:
"∃ suppThreadID suppID PMK authThreadID PTK GTK ANonce SNonce ctr #i.
  (SupplicantReceivesM1( suppThreadID, suppID, PMK, authThreadID, PTK, GTK,
                         ANonce, SNonce, ctr
   ) @ #i)"
*/
by sorry

lemma supplicant_can_rcv_m3 [heuristic=S,
                             hide_lemma=supplicant_gtk_installation_means_auth_sent_gtk,
                             hide_lemma=supplicant_receiver_gtk_must_be_installed,
                             hide_lemma=pmks_are_secret_unless_revealed,
                             hide_lemma=pmks_are_ku_secret_unless_revealed,
                             hide_lemma=authenticator_used_ptks_must_be_installed,
                             hide_lemma=supplicant_used_ptks_must_be_installed,
                             hide_lemma=authenticator_use_gtk_must_be_preceded_by_install_gtk,
                             hide_lemma=authenticator_use_gtk_must_be_preceded_by_set_share_gtk,
                             hide_lemma=authenticator_gtk_rekey_must_be_preceded_by_create,
                             hide_lemma=authenticator_encryption_gtks_must_be_installed,
                             hide_lemma=supplicant_ptk_is_secret,
                             hide_lemma=supplicant_ptk_is_ku_secret,
                             hide_lemma=supplicant_preliminary_ptk_is_secret,
                             hide_lemma=supplicant_preliminary_ptk_is_ku_secret,
                             hide_lemma=supplicant_gtk_is_secret,
                             hide_lemma=supplicant_gtk_is_ku_secret,
                             hide_lemma=authenticator_ptk_is_secret,
                             hide_lemma=authenticator_ptk_is_ku_secret,
                             hide_lemma=authenticator_preliminary_ptk_is_secret,
                             hide_lemma=authenticator_preliminary_ptk_is_ku_secret,
                             hide_lemma=no_nonce_reuse_for_installed_gtk,
                             hide_lemma=authenticator_shared_gtk_is_ku_secret,
                             hide_lemma=authenticator_shared_gtk_is_secret,
                             hide_lemma=authenticator_sets_share_gtk_is_secret,
                             hide_lemma=authenticator_sets_share_gtk_is_ku_secret,
                             hide_lemma=authenticator_use_gtk_must_be_preceded_by_set_share_gtk,
                             hide_lemma=authenticator_gtk_is_secret,
                             hide_lemma=authenticator_gtk_is_ku_secret]:
  exists-trace
  "∃ suppThreadID suppID PMK authThreadID GTK PTK ANonce SNonce ctr #i.
    SupplicantReceivesM3( suppThreadID, suppID, PMK, authThreadID, PTK,
                          ANonce, SNonce, GTK, ctr
    ) @ #i"
/*
guarded formula characterizing all satisfying traces:
"∃ suppThreadID suppID PMK authThreadID GTK PTK ANonce SNonce ctr #i.
  (SupplicantReceivesM3( suppThreadID, suppID, PMK, authThreadID, PTK,
                         ANonce, SNonce, GTK, ctr
   ) @ #i)"
*/
by sorry

lemma supplicant_can_send_m4 [heuristic=S,
                              hide_lemma=supplicant_gtk_installation_means_auth_sent_gtk,
                              hide_lemma=supplicant_receiver_gtk_must_be_installed,
                              hide_lemma=pmks_are_secret_unless_revealed,
                              hide_lemma=pmks_are_ku_secret_unless_revealed,
                              hide_lemma=authenticator_used_ptks_must_be_installed,
                              hide_lemma=supplicant_used_ptks_must_be_installed,
                              hide_lemma=authenticator_use_gtk_must_be_preceded_by_install_gtk,
                              hide_lemma=authenticator_use_gtk_must_be_preceded_by_set_share_gtk,
                              hide_lemma=authenticator_gtk_rekey_must_be_preceded_by_create,
                              hide_lemma=authenticator_encryption_gtks_must_be_installed,
                              hide_lemma=supplicant_ptk_is_secret,
                              hide_lemma=supplicant_ptk_is_ku_secret,
                              hide_lemma=supplicant_preliminary_ptk_is_secret,
                              hide_lemma=supplicant_preliminary_ptk_is_ku_secret,
                              hide_lemma=supplicant_gtk_is_secret,
                              hide_lemma=supplicant_gtk_is_ku_secret,
                              hide_lemma=authenticator_ptk_is_secret,
                              hide_lemma=authenticator_ptk_is_ku_secret,
                              hide_lemma=authenticator_preliminary_ptk_is_secret,
                              hide_lemma=authenticator_preliminary_ptk_is_ku_secret,
                              hide_lemma=no_nonce_reuse_for_installed_gtk,
                              hide_lemma=authenticator_shared_gtk_is_ku_secret,
                              hide_lemma=authenticator_shared_gtk_is_secret,
                              hide_lemma=authenticator_sets_share_gtk_is_secret,
                              hide_lemma=authenticator_sets_share_gtk_is_ku_secret,
                              hide_lemma=authenticator_use_gtk_must_be_preceded_by_set_share_gtk,
                              hide_lemma=authenticator_gtk_is_secret,
                              hide_lemma=authenticator_gtk_is_ku_secret]:
  exists-trace
  "∃ suppThreadID suppID PMK authThreadID PTK ANonce SNonce GTK #i.
    SupplicantSendsM4( suppThreadID, suppID, PMK, authThreadID, PTK, GTK,
                       ANonce, SNonce
    ) @ #i"
/*
guarded formula characterizing all satisfying traces:
"∃ suppThreadID suppID PMK authThreadID PTK ANonce SNonce GTK #i.
  (SupplicantSendsM4( suppThreadID, suppID, PMK, authThreadID, PTK, GTK,
                      ANonce, SNonce
   ) @ #i)"
*/
by sorry

lemma can_install_key [heuristic=S,
                       hide_lemma=supplicant_gtk_installation_means_auth_sent_gtk,
                       hide_lemma=supplicant_receiver_gtk_must_be_installed,
                       hide_lemma=pmks_are_secret_unless_revealed,
                       hide_lemma=pmks_are_ku_secret_unless_revealed,
                       hide_lemma=authenticator_used_ptks_must_be_installed,
                       hide_lemma=supplicant_used_ptks_must_be_installed,
                       hide_lemma=authenticator_use_gtk_must_be_preceded_by_install_gtk,
                       hide_lemma=authenticator_use_gtk_must_be_preceded_by_set_share_gtk,
                       hide_lemma=authenticator_gtk_rekey_must_be_preceded_by_create,
                       hide_lemma=authenticator_encryption_gtks_must_be_installed,
                       hide_lemma=supplicant_ptk_is_secret,
                       hide_lemma=supplicant_ptk_is_ku_secret,
                       hide_lemma=supplicant_preliminary_ptk_is_secret,
                       hide_lemma=supplicant_preliminary_ptk_is_ku_secret,
                       hide_lemma=supplicant_gtk_is_secret,
                       hide_lemma=supplicant_gtk_is_ku_secret,
                       hide_lemma=authenticator_ptk_is_secret,
                       hide_lemma=authenticator_ptk_is_ku_secret,
                       hide_lemma=authenticator_preliminary_ptk_is_secret,
                       hide_lemma=authenticator_preliminary_ptk_is_ku_secret,
                       hide_lemma=no_nonce_reuse_for_installed_gtk,
                       hide_lemma=authenticator_shared_gtk_is_ku_secret,
                       hide_lemma=authenticator_shared_gtk_is_secret,
                       hide_lemma=authenticator_sets_share_gtk_is_secret,
                       hide_lemma=authenticator_sets_share_gtk_is_ku_secret,
                       hide_lemma=authenticator_use_gtk_must_be_preceded_by_set_share_gtk,
                       hide_lemma=authenticator_gtk_is_secret,
                       hide_lemma=authenticator_gtk_is_ku_secret]:
  exists-trace
  "∃ suppThreadID suppID authThreadID authID PMK PTK ptkDfNonce ptkMfNonce
     GTK ANonce SNonce ctr1 #i #j.
    (AuthenticatorInstalled( authThreadID, authID, PMK, suppThreadID, PTK,
                             ANonce, SNonce, ctr1
     ) @ #i) ∧
    (SupplicantInstalledPTK( suppThreadID, suppID, PMK, PTK, ptkDfNonce,
                             ptkMfNonce, GTK, ANonce, SNonce
     ) @ #j)"
/*
guarded formula characterizing all satisfying traces:
"∃ suppThreadID suppID authThreadID authID PMK PTK ptkDfNonce ptkMfNonce
   GTK ANonce SNonce ctr1 #i #j.
  (AuthenticatorInstalled( authThreadID, authID, PMK, suppThreadID, PTK,
                           ANonce, SNonce, ctr1
   ) @ #i) ∧
  (SupplicantInstalledPTK( suppThreadID, suppID, PMK, PTK, ptkDfNonce,
                           ptkMfNonce, GTK, ANonce, SNonce
   ) @ #j)"
*/
by sorry

lemma can_perform_handshakes_in_parallel [heuristic=S,
                                          hide_lemma=supplicant_gtk_installation_means_auth_sent_gtk,
                                          hide_lemma=supplicant_receiver_gtk_must_be_installed,
                                          hide_lemma=pmks_are_secret_unless_revealed,
                                          hide_lemma=pmks_are_ku_secret_unless_revealed,
                                          hide_lemma=authenticator_used_ptks_must_be_installed,
                                          hide_lemma=supplicant_used_ptks_must_be_installed,
                                          hide_lemma=authenticator_use_gtk_must_be_preceded_by_install_gtk,
                                          hide_lemma=authenticator_use_gtk_must_be_preceded_by_set_share_gtk,
                                          hide_lemma=authenticator_gtk_rekey_must_be_preceded_by_create,
                                          hide_lemma=authenticator_encryption_gtks_must_be_installed,
                                          hide_lemma=supplicant_ptk_is_secret,
                                          hide_lemma=supplicant_ptk_is_ku_secret,
                                          hide_lemma=supplicant_preliminary_ptk_is_secret,
                                          hide_lemma=supplicant_preliminary_ptk_is_ku_secret,
                                          hide_lemma=supplicant_gtk_is_secret,
                                          hide_lemma=supplicant_gtk_is_ku_secret,
                                          hide_lemma=authenticator_ptk_is_secret,
                                          hide_lemma=authenticator_ptk_is_ku_secret,
                                          hide_lemma=authenticator_preliminary_ptk_is_secret,
                                          hide_lemma=authenticator_preliminary_ptk_is_ku_secret,
                                          hide_lemma=no_nonce_reuse_for_installed_gtk,
                                          hide_lemma=authenticator_shared_gtk_is_ku_secret,
                                          hide_lemma=authenticator_shared_gtk_is_secret,
                                          hide_lemma=authenticator_sets_share_gtk_is_secret,
                                          hide_lemma=authenticator_sets_share_gtk_is_ku_secret,
                                          hide_lemma=authenticator_use_gtk_must_be_preceded_by_set_share_gtk,
                                          hide_lemma=authenticator_gtk_is_secret,
                                          hide_lemma=authenticator_gtk_is_ku_secret]:
  exists-trace
  "∃ authID authThreadID1 authThreadID2 suppID1 suppID2 suppThreadID1
     suppThreadID2 PMK1 PMK2 ptkDfNonce1 ptkMfNonce1 ptkDfNonce2 ptkMfNonce2
     PTK1 PTK2 GTK ANonce1 ANonce2 SNonce1 SNonce2 #i #j #k #l.
    (((((Associate( authID, authThreadID1, suppID1, suppThreadID1, PMK1
         ) @ #i) ∧
        (Associate( authID, authThreadID2, suppID2, suppThreadID2, PMK2
         ) @ #j)) ∧
       (#i < #j)) ∧
      (#k < #l)) ∧
     (SupplicantInstalledPTK( suppThreadID2, suppID2, PMK2, PTK2, ptkDfNonce2,
                              ptkMfNonce2, GTK, ANonce2, SNonce2
      ) @ #k)) ∧
    (SupplicantInstalledPTK( suppThreadID1, suppID1, PMK1, PTK1, ptkDfNonce1,
                             ptkMfNonce1, GTK, ANonce1, SNonce1
     ) @ #l)"
/*
guarded formula characterizing all satisfying traces:
"∃ authID authThreadID1 authThreadID2 suppID1 suppID2 suppThreadID1
   suppThreadID2 PMK1 PMK2 ptkDfNonce1 ptkMfNonce1 ptkDfNonce2 ptkMfNonce2
   PTK1 PTK2 GTK ANonce1 ANonce2 SNonce1 SNonce2 #i #j #k #l.
  (Associate( authID, authThreadID1, suppID1, suppThreadID1, PMK1 ) @ #i) ∧
  (Associate( authID, authThreadID2, suppID2, suppThreadID2, PMK2 ) @ #j) ∧
  (SupplicantInstalledPTK( suppThreadID2, suppID2, PMK2, PTK2, ptkDfNonce2,
                           ptkMfNonce2, GTK, ANonce2, SNonce2
   ) @ #k) ∧
  (SupplicantInstalledPTK( suppThreadID1, suppID1, PMK1, PTK1, ptkDfNonce1,
                           ptkMfNonce1, GTK, ANonce1, SNonce1
   ) @ #l)
 ∧
  (#i < #j) ∧ (#k < #l)"
*/
by sorry

lemma can_rekey [heuristic=S,
                 hide_lemma=supplicant_gtk_installation_means_auth_sent_gtk,
                 hide_lemma=supplicant_receiver_gtk_must_be_installed,
                 hide_lemma=pmks_are_secret_unless_revealed,
                 hide_lemma=pmks_are_ku_secret_unless_revealed,
                 hide_lemma=authenticator_used_ptks_must_be_installed,
                 hide_lemma=supplicant_used_ptks_must_be_installed,
                 hide_lemma=authenticator_use_gtk_must_be_preceded_by_install_gtk,
                 hide_lemma=authenticator_use_gtk_must_be_preceded_by_set_share_gtk,
                 hide_lemma=authenticator_gtk_rekey_must_be_preceded_by_create,
                 hide_lemma=authenticator_encryption_gtks_must_be_installed,
                 hide_lemma=supplicant_ptk_is_secret,
                 hide_lemma=supplicant_ptk_is_ku_secret,
                 hide_lemma=supplicant_preliminary_ptk_is_secret,
                 hide_lemma=supplicant_preliminary_ptk_is_ku_secret,
                 hide_lemma=supplicant_gtk_is_secret,
                 hide_lemma=supplicant_gtk_is_ku_secret,
                 hide_lemma=authenticator_ptk_is_secret,
                 hide_lemma=authenticator_ptk_is_ku_secret,
                 hide_lemma=authenticator_preliminary_ptk_is_secret,
                 hide_lemma=authenticator_preliminary_ptk_is_ku_secret,
                 hide_lemma=no_nonce_reuse_for_installed_gtk,
                 hide_lemma=authenticator_shared_gtk_is_ku_secret,
                 hide_lemma=authenticator_shared_gtk_is_secret,
                 hide_lemma=authenticator_sets_share_gtk_is_secret,
                 hide_lemma=authenticator_sets_share_gtk_is_ku_secret,
                 hide_lemma=authenticator_use_gtk_must_be_preceded_by_set_share_gtk,
                 hide_lemma=authenticator_gtk_is_secret,
                 hide_lemma=authenticator_gtk_is_ku_secret]:
  exists-trace
  "∃ authThreadID authID PMK suppThreadID1 suppThreadID2 PTK1 PTK2 ANonce1
     ANonce2 SNonce1 SNonce2 ctr1 ctr2 #i #j.
    ((AuthenticatorInstalled( authThreadID, authID, PMK, suppThreadID1, PTK1,
                              ANonce1, SNonce1, ctr1
      ) @ #i) ∧
     (AuthenticatorInstalled( authThreadID, authID, PMK, suppThreadID2, PTK2,
                              ANonce2, SNonce2, ctr2
      ) @ #j)) ∧
    (¬(#i = #j))"
/*
guarded formula characterizing all satisfying traces:
"∃ authThreadID authID PMK suppThreadID1 suppThreadID2 PTK1 PTK2 ANonce1
   ANonce2 SNonce1 SNonce2 ctr1 ctr2 #i #j.
  (AuthenticatorInstalled( authThreadID, authID, PMK, suppThreadID1, PTK1,
                           ANonce1, SNonce1, ctr1
   ) @ #i) ∧
  (AuthenticatorInstalled( authThreadID, authID, PMK, suppThreadID2, PTK2,
                           ANonce2, SNonce2, ctr2
   ) @ #j)
 ∧
  ¬(#i = #j)"
*/
by sorry

lemma can_receive_group_payloads [heuristic=S,
                                  hide_lemma=supplicant_gtk_installation_means_auth_sent_gtk,
                                  hide_lemma=supplicant_receiver_gtk_must_be_installed,
                                  hide_lemma=pmks_are_secret_unless_revealed,
                                  hide_lemma=pmks_are_ku_secret_unless_revealed,
                                  hide_lemma=authenticator_used_ptks_must_be_installed,
                                  hide_lemma=supplicant_used_ptks_must_be_installed,
                                  hide_lemma=authenticator_use_gtk_must_be_preceded_by_install_gtk,
                                  hide_lemma=authenticator_use_gtk_must_be_preceded_by_set_share_gtk,
                                  hide_lemma=authenticator_gtk_rekey_must_be_preceded_by_create,
                                  hide_lemma=authenticator_encryption_gtks_must_be_installed,
                                  hide_lemma=supplicant_ptk_is_secret,
                                  hide_lemma=supplicant_ptk_is_ku_secret,
                                  hide_lemma=supplicant_preliminary_ptk_is_secret,
                                  hide_lemma=supplicant_preliminary_ptk_is_ku_secret,
                                  hide_lemma=supplicant_gtk_is_secret,
                                  hide_lemma=supplicant_gtk_is_ku_secret,
                                  hide_lemma=authenticator_ptk_is_secret,
                                  hide_lemma=authenticator_ptk_is_ku_secret,
                                  hide_lemma=authenticator_preliminary_ptk_is_secret,
                                  hide_lemma=authenticator_preliminary_ptk_is_ku_secret,
                                  hide_lemma=no_nonce_reuse_for_installed_gtk,
                                  hide_lemma=authenticator_shared_gtk_is_ku_secret,
                                  hide_lemma=authenticator_shared_gtk_is_secret,
                                  hide_lemma=authenticator_sets_share_gtk_is_secret,
                                  hide_lemma=authenticator_sets_share_gtk_is_ku_secret,
                                  hide_lemma=authenticator_use_gtk_must_be_preceded_by_set_share_gtk,
                                  hide_lemma=authenticator_gtk_is_secret,
                                  hide_lemma=authenticator_gtk_is_ku_secret]:
  exists-trace
  "∃ keyID suppThreadID PMK groupKey nonce1 nonce2 #i #j.
    ((ReceiveGTKEncryptedPayload( keyID, suppThreadID, PMK, groupKey, nonce1
      ) @ #i) ∧
     (ReceiveGTKEncryptedPayload( keyID, suppThreadID, PMK, groupKey, nonce2
      ) @ #j)) ∧
    (#i < #j)"
/*
guarded formula characterizing all satisfying traces:
"∃ keyID suppThreadID PMK groupKey nonce1 nonce2 #i #j.
  (ReceiveGTKEncryptedPayload( keyID, suppThreadID, PMK, groupKey, nonce1
   ) @ #i) ∧
  (ReceiveGTKEncryptedPayload( keyID, suppThreadID, PMK, groupKey, nonce2
   ) @ #j)
 ∧
  #i < #j"
*/
by sorry

lemma authenticator_can_install_new_gtk [heuristic=S,
                                         hide_lemma=supplicant_gtk_installation_means_auth_sent_gtk,
                                         hide_lemma=supplicant_receiver_gtk_must_be_installed,
                                         hide_lemma=pmks_are_secret_unless_revealed,
                                         hide_lemma=pmks_are_ku_secret_unless_revealed,
                                         hide_lemma=authenticator_used_ptks_must_be_installed,
                                         hide_lemma=supplicant_used_ptks_must_be_installed,
                                         hide_lemma=authenticator_use_gtk_must_be_preceded_by_install_gtk,
                                         hide_lemma=authenticator_use_gtk_must_be_preceded_by_set_share_gtk,
                                         hide_lemma=authenticator_gtk_rekey_must_be_preceded_by_create,
                                         hide_lemma=authenticator_encryption_gtks_must_be_installed,
                                         hide_lemma=supplicant_ptk_is_secret,
                                         hide_lemma=supplicant_ptk_is_ku_secret,
                                         hide_lemma=supplicant_preliminary_ptk_is_secret,
                                         hide_lemma=supplicant_preliminary_ptk_is_ku_secret,
                                         hide_lemma=supplicant_gtk_is_secret,
                                         hide_lemma=supplicant_gtk_is_ku_secret,
                                         hide_lemma=authenticator_ptk_is_secret,
                                         hide_lemma=authenticator_ptk_is_ku_secret,
                                         hide_lemma=authenticator_preliminary_ptk_is_secret,
                                         hide_lemma=authenticator_preliminary_ptk_is_ku_secret,
                                         hide_lemma=no_nonce_reuse_for_installed_gtk,
                                         hide_lemma=authenticator_shared_gtk_is_ku_secret,
                                         hide_lemma=authenticator_shared_gtk_is_secret,
                                         hide_lemma=authenticator_sets_share_gtk_is_secret,
                                         hide_lemma=authenticator_sets_share_gtk_is_ku_secret,
                                         hide_lemma=authenticator_use_gtk_must_be_preceded_by_set_share_gtk,
                                         hide_lemma=authenticator_gtk_is_secret,
                                         hide_lemma=authenticator_gtk_is_ku_secret]:
  exists-trace
  "∃ authID shareGTKData authThreadID1 suppID1 suppThreadID1 PMK1
     authThreadID2 suppID2 suppThreadID2 PMK2 #i #j #k.
    ((((Associate( authID, authThreadID1, suppID1, suppThreadID1, PMK1
        ) @ #i) ∧
       (Associate( authID, authThreadID2, suppID2, suppThreadID2, PMK2
        ) @ #j)) ∧
      (AuthenticatorInstalledGTK( authID, shareGTKData ) @ #k)) ∧
     (#i < #k)) ∧
    (#j < #k)"
/*
guarded formula characterizing all satisfying traces:
"∃ authID shareGTKData authThreadID1 suppID1 suppThreadID1 PMK1
   authThreadID2 suppID2 suppThreadID2 PMK2 #i #j #k.
  (Associate( authID, authThreadID1, suppID1, suppThreadID1, PMK1 ) @ #i) ∧
  (Associate( authID, authThreadID2, suppID2, suppThreadID2, PMK2 ) @ #j) ∧
  (AuthenticatorInstalledGTK( authID, shareGTKData ) @ #k)
 ∧
  (#i < #k) ∧ (#j < #k)"
*/
by sorry

lemma krack_attack_ptk [heuristic=S,
                        hide_lemma=supplicant_gtk_installation_means_auth_sent_gtk,
                        hide_lemma=supplicant_receiver_gtk_must_be_installed,
                        hide_lemma=pmks_are_secret_unless_revealed,
                        hide_lemma=pmks_are_ku_secret_unless_revealed,
                        hide_lemma=authenticator_used_ptks_must_be_installed,
                        hide_lemma=supplicant_used_ptks_must_be_installed,
                        hide_lemma=authenticator_use_gtk_must_be_preceded_by_install_gtk,
                        hide_lemma=authenticator_use_gtk_must_be_preceded_by_set_share_gtk,
                        hide_lemma=authenticator_gtk_rekey_must_be_preceded_by_create,
                        hide_lemma=authenticator_encryption_gtks_must_be_installed,
                        hide_lemma=supplicant_ptk_is_secret,
                        hide_lemma=supplicant_ptk_is_ku_secret,
                        hide_lemma=supplicant_preliminary_ptk_is_secret,
                        hide_lemma=supplicant_preliminary_ptk_is_ku_secret,
                        hide_lemma=supplicant_gtk_is_secret,
                        hide_lemma=supplicant_gtk_is_ku_secret,
                        hide_lemma=authenticator_ptk_is_secret,
                        hide_lemma=authenticator_ptk_is_ku_secret,
                        hide_lemma=authenticator_preliminary_ptk_is_secret,
                        hide_lemma=authenticator_preliminary_ptk_is_ku_secret,
                        hide_lemma=no_nonce_reuse_for_installed_gtk,
                        hide_lemma=authenticator_shared_gtk_is_ku_secret,
                        hide_lemma=authenticator_shared_gtk_is_secret,
                        hide_lemma=authenticator_sets_share_gtk_is_secret,
                        hide_lemma=authenticator_sets_share_gtk_is_ku_secret,
                        hide_lemma=authenticator_use_gtk_must_be_preceded_by_set_share_gtk,
                        hide_lemma=authenticator_gtk_is_secret,
                        hide_lemma=authenticator_gtk_is_ku_secret]:
  exists-trace
  "∃ suppThreadID suppID PMK PTK ptkDfNonce ptkMfNonce GTK ANonce SNonce #i
     #j.
    (SupplicantInstalledPTK( suppThreadID, suppID, PMK, PTK, ptkDfNonce,
                             ptkMfNonce, GTK, ANonce, SNonce
     ) @ #i) ∧
    (K( PTK ) @ #j)"
/*
guarded formula characterizing all satisfying traces:
"∃ suppThreadID suppID PMK PTK ptkDfNonce ptkMfNonce GTK ANonce SNonce #i
   #j.
  (SupplicantInstalledPTK( suppThreadID, suppID, PMK, PTK, ptkDfNonce,
                           ptkMfNonce, GTK, ANonce, SNonce
   ) @ #i) ∧
  (K( PTK ) @ #j)"
*/
by sorry

/* All well-formedness checks were successful. */

end